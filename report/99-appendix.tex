\appendix
\chapter{Listato commentato del codice} \label{app:allcode}

\section{Strutture di \textit{input}}
\lipsum[1]

\subsection{\texttt{Input\_gpu\_data}}
\lipsum[1-3]

\begin{lstlisting}[language=C++, caption={\texttt{libraries/InputStructures/InputGPUData/Input\_gpu\_data.cuh}}]
#ifndef __Input_gpu_data_h__
#define __Input_gpu_data_h__

#define NUMBER_OF_THREADS_PER_BLOCK 512

struct Input_gpu_data{
	unsigned int NumberOfBlocks;

	__device__ __host__ unsigned int GetNumberOfThreadsPerBlock() const;
	__device__ __host__ unsigned int GetTotalNumberOfThreads() const;

};
#endif
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={\texttt{libraries/InputStructures/InputGPUData/Input\_gpu\_data.cu}}]
#include "Input_gpu_data.cuh"

using namespace std;

__device__ __host__ unsigned int Input_gpu_data::GetNumberOfThreadsPerBlock() const{
	return NUMBER_OF_THREADS_PER_BLOCK;
}

__device__ __host__ unsigned int Input_gpu_data::GetTotalNumberOfThreads() const{
	return this->NumberOfBlocks * NUMBER_OF_THREADS_PER_BLOCK;
}
\end{lstlisting}

\subsection{\texttt{Input\_market\_data}}
\lipsum[1-3]

\begin{lstlisting}[language=C++, caption={\texttt{libraries/InputStructures/InputMarketData/Input\_market\_data.cuh}}]
#ifndef __Input_Market_data_h__
#define __Input_Market_data_h__

struct Input_market_data{
	
	double InitialPrice;				// Initial price of the asset
	double Volatility;					// Volatility
	double RiskFreeRate;				// Risk-free interest

};
#endif
\end{lstlisting}

\subsection{\texttt{Input\_option\_data}}
\lipsum[1-3]

\begin{lstlisting}[language=C++, caption={\texttt{libraries/InputStructures/InputOptionData/Input\_option\_data.cuh}}]
#ifndef __Input_option_data_h__
#define __Input_option_data_h__

struct Input_option_data{
	
	// Common to all option types
	char OptionType;		// f = forward contract
							// c = plain vanilla call option
							// p = plain vanilla put option
							// e = performance corridor option
	unsigned int NumberOfIntervals;
	double TimeToMaturity;

	__device__ __host__ double GetDeltaTime() const;
	
	// Specific to plain vanilla options
	double StrikePrice;
		
	// Specific to performance corridor options
	double B;
	double K;
	double N;

};

#endif
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={\texttt{libraries/InputStructures/InputOptionData/Input\_option\_data.cu}}]
#include "Input_option_data.cuh"

using namespace std;

__device__ __host__ double Input_option_data::GetDeltaTime() const{
	return static_cast<double>(static_cast<double>(this->TimeToMaturity) / static_cast<unsigned int>(this->NumberOfIntervals));	
}
\end{lstlisting}

\subsection{\texttt{Input\_MC\_data}}
\lipsum[1-3]

\begin{lstlisting}[language=C++, caption={\texttt{libraries/InputStructures/InputMCData/Input\_MC\_data.cuh}}]
#ifndef __Input_MC_data_h__
#define __Input_MC_data_h__

#include "../InputGPUData/Input_gpu_data.cuh"

struct Input_MC_data{

	unsigned int NumberOfMCSimulations;
	char CpuOrGpu;	// g = gpu algorithm only
					// c = cpu algorithm only
					// b = both algorithms are used
	char GaussianOrBimodal;	// g = gaussian variables are used
							// b = bimodal (1/-1) variables are used
	
	__device__ __host__ unsigned int GetNumberOfSimulationsPerThread(const Input_gpu_data&) const;

};

#endif
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={\texttt{libraries/InputStructures/InputMCData/Input\_MC\_data.cu}}]
#include <cmath>	// ceil

#include "Input_MC_data.cuh"
#include "../InputGPUData/Input_gpu_data.cuh"

using namespace std;

__device__ __host__ unsigned int Input_MC_data::GetNumberOfSimulationsPerThread(const Input_gpu_data& inputGPU) const{
	return ceil(static_cast<double>(this->NumberOfMCSimulations) / inputGPU.GetTotalNumberOfThreads());
}
\end{lstlisting}

\section{Strutture di \textit{output}}
\lipsum[1]

\subsection{\texttt{Output\_MC\_data}}
\lipsum[1-3]

\begin{lstlisting}[language=C++, caption={\texttt{libraries/OutputStructures/OutputMCData/Output\_MC\_data.cuh}}]
#ifndef __Output_MC_data_h__
#define __Output_MC_data_h__

struct Output_MC_data{
	
	char HostOrDevice;
	double EstimatedPriceMCEuler;
	double ErrorMCEuler;
	double EstimatedPriceMCExact;
	double ErrorMCExact;
	double Tick;			// Calculation time [ms]
	unsigned int NegativePriceCounter;
	
	__device__ __host__ double GetRelativeErrorEuler() const;
	__device__ __host__ double GetRelativeErrorExact() const;
	__device__ __host__ double GetEulerToExactDiscrepancy() const;

};

#endif
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={\texttt{libraries/OutputStructures/OutputMCData/Output\_MC\_data.cu}}]
#include <cmath>	// fabs, sqrt, pow

#include "Output_MC_data.cuh"

__device__ __host__ double Output_MC_data::GetRelativeErrorEuler() const{
	return this->ErrorMCEuler / this->EstimatedPriceMCEuler;
}

__device__ __host__ double Output_MC_data::GetRelativeErrorExact() const{
	return this->ErrorMCExact / this->EstimatedPriceMCExact;
}

__device__ __host__ double Output_MC_data::GetEulerToExactDiscrepancy() const{
	return fabs((this->EstimatedPriceMCEuler - this->EstimatedPriceMCExact)/sqrt(pow(this->ErrorMCEuler,2)+pow(ErrorMCExact,2)));
}
\end{lstlisting}

\section{Librerie principali}
\lipsum[1]

\subsection{\texttt{RNG}, \texttt{RNG\_Tausworthe}, \texttt{RNG\_Combined}}
\lipsum[1-3]

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/RandomGenerator/RNG.cuh}}]
#ifndef _RNG__H
#define _RNG__H

class RNG{
	
	public:
		// Virtual functions from base class
		__device__ __host__ virtual void ResetSeed() = 0;
		__device__ __host__ virtual unsigned int GetUnsignedInt() = 0;
		__device__ __host__ virtual double GetUniform() = 0;
		__device__ __host__ virtual double GetGauss() = 0;
		__device__ __host__ virtual double GetBimodal() = 0;
		__device__ __host__ virtual void SetInternalState(RNG*) = 0;
		
};

class RNG_Tausworthe: public RNG{
	
	private:
		
		unsigned int _Seed;
		
		__device__ __host__ unsigned int TausStep();
	
	public:
	
		// Constructors and destructor
		__device__ __host__ RNG_Tausworthe();
		__device__ __host__ RNG_Tausworthe(const unsigned int);
		__device__ __host__ ~RNG_Tausworthe() = default;	
		
		// Virtual functions from base class
		__device__ __host__ void ResetSeed();
		__device__ __host__ unsigned int GetUnsignedInt();
		__device__ __host__ double GetUniform();
		__device__ __host__ double GetGauss();
		__device__ __host__ double GetBimodal();
		__device__ __host__ void SetInternalState(RNG*);
		
};

class RNG_CombinedGenerator: public RNG{
	
	public:
	
		// Constructors and destructor
		__device__ __host__ RNG_CombinedGenerator();
		__device__ __host__ RNG_CombinedGenerator(const unsigned int, const unsigned int, const unsigned int, const unsigned int);
		__device__ __host__ ~RNG_CombinedGenerator() = default;
		
		// Virtual functions from base class
		__device__ __host__ void ResetSeed();
		__device__ __host__ unsigned int GetUnsignedInt();
		__device__ __host__ double GetUniform();
		__device__ __host__ double GetGauss();
		__device__ __host__ double GetBimodal();

		// Public internal state set (unsigned ints between 129 and UINT_MAX)
		__device__ __host__ void SetInternalState(RNG*);
	
	private:
		// Seeds: 3 taus + 1 LCGS
		unsigned int _SeedLCGS;
		unsigned int _SeedTaus1;
		unsigned int _SeedTaus2;
		unsigned int _SeedTaus3;
		
		// Single steps (callable from device and host, no need to diversify)
		__device__ __host__ unsigned int LCGStep();
		__device__ __host__ unsigned int TausStep1();
		__device__ __host__ unsigned int TausStep2();
		__device__ __host__ unsigned int TausStep3();
		__device__ __host__ unsigned int HybridTausGenerator();
};

#endif
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/RandomGenerator/RNG.cu}}]
#include <cmath>		// log, cos, sin, M_PI

#include "RNG.cuh"

using namespace std;

//
//	TAUSWORTHE GENERATOR
//

// Constructor and destructor
__device__ __host__ RNG_Tausworthe::RNG_Tausworthe(){
	_Seed = 129;
}
__device__ __host__ RNG_Tausworthe::RNG_Tausworthe(const unsigned int seed){
	_Seed = seed;
}

// Private functions
__device__ __host__ unsigned int RNG_Tausworthe::TausStep(){
	int S1 = 23, S2 = 5, S3 = 29;
	unsigned int M = 4294967240UL;
	unsigned int z = this->_Seed;
	
	unsigned b = (((z << S1) ^ z) >> S2);

	this->_Seed = (((z & M) << S3) ^ b);
	return _Seed;		
}

// Virtual functions from base class
__device__ __host__ void RNG_Tausworthe::ResetSeed(){
	_Seed = 129;	
}

__device__ __host__ unsigned int RNG_Tausworthe::GetUnsignedInt(){
	return this->TausStep();
}

__device__ __host__ double RNG_Tausworthe::GetUniform(){
	return 2.3283064365387e-10 * this->GetUnsignedInt();	
}

__device__ __host__ double RNG_Tausworthe::GetGauss(){
	double u = this->GetUniform();
	double v = this->GetUniform();

	return sqrt(-2.*log(u)) * cos(2.*M_PI*v);	
}

__device__ __host__ double RNG_Tausworthe::GetBimodal(){
	double gaussian;

	do{
		gaussian = this->GetGauss();
		
		if(gaussian > 0.)
			return 1.;
		else if(gaussian < 0.)
			return -1.;
	}while(gaussian == 0.);
	
	return -1000.;	// If this ever gets called, we're in trouble
}

__device__ __host__ void RNG_Tausworthe::SetInternalState(RNG* supportGenerator){
	unsigned int seed;
	
	do
		seed = supportGenerator->GetUnsignedInt();
	while(seed < 129);
	
	this->_Seed = seed;
}

//
//	COMBINED GENERATOR
//

__device__ __host__ RNG_CombinedGenerator::RNG_CombinedGenerator(const unsigned int seed1, const unsigned int seed2, const unsigned int seed3, const unsigned int seed4){
	this->_SeedLCGS = seed1;
	this->_SeedTaus1 = seed2;
	this->_SeedTaus2 = seed3;
	this->_SeedTaus3 = seed4;
}

__device__ __host__ RNG_CombinedGenerator::RNG_CombinedGenerator(){
	this->_SeedLCGS = 0;
	this->_SeedTaus1 = 129;
	this->_SeedTaus2 = 130;
	this->_SeedTaus3 = 131;
}

__device__ __host__ unsigned int RNG_CombinedGenerator::TausStep1(){
	int S1 = 13, S2 = 19, S3 = 12;
	unsigned int M = 4294967294UL;
	unsigned int z = this->_SeedTaus1;
	
	unsigned b = (((z << S1) ^ z) >> S2);
	
	this->_SeedTaus1 = (((z & M) << S3) ^ b);
	return _SeedTaus1;
}

__device__ __host__ unsigned int RNG_CombinedGenerator::TausStep2(){
	int S1 = 2, S2 = 25, S3 = 4;
	unsigned int M = 4294967288UL;
	unsigned int z = this->_SeedTaus2;
	
	unsigned b = (((z << S1) ^ z) >> S2);

	this->_SeedTaus2 = (((z & M) << S3) ^ b);
	return _SeedTaus2;
}
__device__ __host__ unsigned int RNG_CombinedGenerator::TausStep3(){
	int S1 = 3, S2 = 11, S3 = 17;
	unsigned int M = 4294967280UL;
	unsigned int z = this->_SeedTaus3;
	
	unsigned b = (((z << S1) ^ z) >> S2);

	this->_SeedTaus3 = (((z & M) << S3) ^ b);
	return _SeedTaus3;
}

__device__ __host__ unsigned int RNG_CombinedGenerator::LCGStep(){
	unsigned int z = this->_SeedLCGS;
	unsigned int A = 1664525;
	unsigned int C = 1013904223UL;
	this->_SeedLCGS = (A*z + C);
	return _SeedLCGS;
}

__device__ __host__ unsigned int RNG_CombinedGenerator::HybridTausGenerator(){
	return (
		this->TausStep1() ^
		this->TausStep2() ^
		this->TausStep3() ^
		this->LCGStep()
	);
}

__device__ __host__ void RNG_CombinedGenerator::ResetSeed(){
	this->_SeedLCGS = 0;
	this->_SeedTaus1 = 129;
	this->_SeedTaus2 = 130;
	this->_SeedTaus3 = 131;
}

__device__ __host__ unsigned int RNG_CombinedGenerator::GetUnsignedInt(){
	return this->HybridTausGenerator();
}

__device__ __host__ double RNG_CombinedGenerator::GetUniform(){
	return 2.3283064365387e-10 * this->GetUnsignedInt();
}

__device__ __host__ double RNG_CombinedGenerator::GetGauss(){
	double u = this->GetUniform();
	double v = this->GetUniform();

	return sqrt(-2.*log(u)) * cos(2.*M_PI*v);
}

__device__ __host__ double RNG_CombinedGenerator::GetBimodal(){
	double gaussian;

	do{
		gaussian = this->GetGauss();
		
		if(gaussian > 0.)
			return 1.;
		else if(gaussian < 0.)
			return -1.;
	}while(gaussian == 0.);

	return -1000.;	// If this ever gets called, we're in trouble
}

__device__ __host__ void RNG_CombinedGenerator::SetInternalState(RNG* supportGenerator){
	this->_SeedLCGS = supportGenerator->GetUnsignedInt();
	
	unsigned int seedTaus1, seedTaus2, seedTaus3;
	
	do
		seedTaus1 = supportGenerator->GetUnsignedInt();
	while(seedTaus1 < 129);
	
	do
		seedTaus2 = supportGenerator->GetUnsignedInt();
	while(seedTaus2 < 129);
	
	do
		seedTaus3 = supportGenerator->GetUnsignedInt();
	while(seedTaus3 < 129);
	
	this->_SeedTaus1 = seedTaus1;
	this->_SeedTaus2 = seedTaus2;
	this->_SeedTaus3 = seedTaus3;
}
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/RandomGenerator/CorrelationToolbox.cuh}}]
#ifndef _CORRELATION__TOOLBOX_CUH
#define _CORRELATION__TOOLBOX_CUH

#include "RNG.cuh"

// Random number generator
__host__ void RandomNumberGeneration(unsigned int numberOfBlocks, unsigned int numberOfThreadsPerBlock, double **uniformNumbers, double **gaussianNumbers, unsigned int totalNumbersToGenerate, unsigned int numbersToGeneratePerThread, unsigned int seed);

// Single stream toolbox. A true verbose variable will print the output for further testing
__host__ double GetAverage_SingleStream(double *inputStream, unsigned int streamSize);
__host__ double GetVariance_SingleStream(double *inputStream, double streamAverage, unsigned int streamSize);
__host__ double GetKurtosis_SingleStream(double *inputStream, double streamAverage, double streamVariance, unsigned int streamSize);
__host__ double GetAutocorrelationK_SingleStream(double *inputStream, unsigned int autocorrelationOffset, unsigned int streamSize);
	// Accepts two vectors: one is streamSize sized, the other is streamSize-2
__host__ void EvaluateCompleteAutocorrelation_SingleStream(double *inputStream, double *outputCorrelations, unsigned int streamSize, bool verbose);


// Many-streams toolbox. A true verbose variable will print the output for further testing
__host__ void EvaluateAverage_MultipleStreams(double **inputStreams, double *outputStreamAverages, unsigned int totalNumberOfThreads, unsigned int numbersToGeneratePerThread, bool verbose);
__host__ void EvaluateVariance_MultipleStreams(double **inputStreams, double *inputStreamAverages, double *outputStreamVariances, unsigned int totalNumberOfThreads, unsigned int numbersToGeneratePerThread, bool verbose);
__host__ void EvaluateKurtosis_MultipleStreams(double **inputStreams, double *inputStreamAverages, double *inputStreamVariances, double *outputStreamKurtosises, unsigned int totalNumberOfThreads, unsigned int numbersToGeneratePerThread, bool verbose);
	// Accepts two matrixes with totalNumberOfThreads as first index and numbersToGeneratePerThread or numbersToGeneratePerThread-2 as second index respectively
__host__ void EvaluateCompleteAutocorrelation_MultipleStreams(double **inputStreams, double **outputStreamCorrelations, unsigned int totalNumberOfThreads, unsigned int numbersToGeneratePerThread, bool verbose);

#endif
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/RandomGenerator/CorrelationToolbox.cu}}]
#include <iostream>

#include "CorrelationToolbox.cuh"

using namespace std;

// Random number generator

__host__ void RandomNumberGeneration(unsigned int numberOfBlocks, unsigned int numberOfThreadsPerBlock, double **uniformNumbers, double **gaussianNumbers, unsigned int totalNumbersToGenerate, unsigned int numbersToGeneratePerThread, unsigned int seed){

	for(unsigned int threadNumber=0; threadNumber<numberOfBlocks*numberOfThreadsPerBlock; ++threadNumber){
		RNG *supportGenerator = new RNG_Tausworthe(seed+threadNumber);
		RNG *mainGenerator = new RNG_CombinedGenerator;
		mainGenerator->SetInternalState(supportGenerator);

		for(unsigned int RNGNumber=0; RNGNumber<numbersToGeneratePerThread; ++RNGNumber){		
			if(numbersToGeneratePerThread*threadNumber+RNGNumber < totalNumbersToGenerate){
				uniformNumbers[threadNumber][RNGNumber] = mainGenerator->GetUniform();
				gaussianNumbers[threadNumber][RNGNumber] = mainGenerator->GetGauss();
			}
		}
	}
}

// Single stream toolbox
__host__ double GetAverage_SingleStream(double *inputStream, unsigned int streamSize){
	double streamSum = 0.;
	unsigned int streamCounter = 0;
	
	for(unsigned int RNGIndex=0; RNGIndex<streamSize; ++RNGIndex){
		streamSum += inputStream[RNGIndex];
		++streamCounter;
	}
	
	return streamSum / streamCounter;
}

__host__ double GetVariance_SingleStream(double *inputStream, double streamAverage, unsigned int streamSize){
	double streamSquaredDiscrepancyFromAverage = 0.;
	unsigned int streamCounter = 0;

	for(unsigned int RNGIndex=0; RNGIndex<streamSize; ++RNGIndex){
		streamSquaredDiscrepancyFromAverage += pow(inputStream[RNGIndex] - streamAverage,2);
		++streamCounter;
	}
	
	return streamSquaredDiscrepancyFromAverage / streamCounter;	
}

__host__ double GetKurtosis_SingleStream(double *inputStream, double streamAverage, double streamVariance, unsigned int streamSize){
	double streamQuarticDiscrepancyFromAverage = 0.;
	unsigned int streamCounter = 0;
	
	for(unsigned int RNGIndex=0; RNGIndex<streamSize; ++RNGIndex){
		streamQuarticDiscrepancyFromAverage += pow(inputStream[RNGIndex] - streamAverage,4);
		++streamCounter;
	}
	
	return streamQuarticDiscrepancyFromAverage / (streamCounter * pow(streamVariance,4));

}

__host__ double GetAutocorrelationK_SingleStream(double *inputStream, unsigned int autocorrelationOffset, unsigned int streamSize){
	double streamCorrelationSum = 0.;
	unsigned int streamCounter = 0;

	for(unsigned int RNGIndex=0; RNGIndex<streamSize-autocorrelationOffset; ++RNGIndex){
		streamCorrelationSum += inputStream[RNGIndex] * inputStream[RNGIndex+autocorrelationOffset];
		++streamCounter;
	}
	
	return streamCorrelationSum / streamCounter;
}

__host__ void EvaluateCompleteAutocorrelation_SingleStream(double *inputStream, double *outputCorrelations, unsigned int streamSize, bool verbose){
	for(unsigned int autocorrelationOffset=1; autocorrelationOffset<streamSize-1; ++autocorrelationOffset){
		outputCorrelations[autocorrelationOffset-1] = GetAutocorrelationK_SingleStream(inputStream, autocorrelationOffset, streamSize);
		
		if(verbose)
			if(autocorrelationOffset % 20 == 0)
				cout << "<xi*xi+" << autocorrelationOffset << ">:\t" << outputCorrelations[autocorrelationOffset-1] << endl;
	}
}


// Toolbox to test correlation of a stream of totalNumberOfThreads, each generating numbersToGeneratePerThread random numbers. A positive verbose variable will, well, print the output for further testing

__host__ void EvaluateAverage_MultipleStreams(double **inputStreams, double *outputStreamAverages, unsigned int totalNumberOfThreads, unsigned int numbersToGeneratePerThread, bool verbose){
	for(unsigned int threadIndex=0; threadIndex<totalNumberOfThreads; ++threadIndex){
		outputStreamAverages[threadIndex] = GetAverage_SingleStream(inputStreams[threadIndex],numbersToGeneratePerThread);	
		if(verbose)
			cout << "<xi>@thread" << threadIndex << ":\t" << outputStreamAverages[threadIndex] << endl;
	}
}

__host__ void EvaluateVariance_MultipleStreams(double **inputStreams, double *inputStreamAverages, double *outputStreamVariances, unsigned int totalNumberOfThreads, unsigned int numbersToGeneratePerThread, bool verbose){
	for(unsigned int threadIndex=0; threadIndex<totalNumberOfThreads; ++threadIndex){
		outputStreamVariances[threadIndex] = GetVariance_SingleStream(inputStreams[threadIndex], inputStreamAverages[threadIndex], numbersToGeneratePerThread);
		if(verbose)
			cout << "var(xi)@thread" << threadIndex << ":\t" << outputStreamVariances[threadIndex] << endl;
	}
}

__host__ void EvaluateKurtosis_MultipleStreams(double **inputStreams, double *inputStreamAverages, double *inputStreamVariances, double *outputStreamKurtosises, unsigned int totalNumberOfThreads, unsigned int numbersToGeneratePerThread, bool verbose){
	for(unsigned int threadIndex=0; threadIndex<totalNumberOfThreads; ++threadIndex){
		outputStreamKurtosises[threadIndex] = GetKurtosis_SingleStream(inputStreams[threadIndex], inputStreamAverages[threadIndex], inputStreamVariances[threadIndex], numbersToGeneratePerThread);
		if(verbose)
			cout << "kurt(xi)@thread" << threadIndex << ":\t" << outputStreamKurtosises[threadIndex] << endl;
	}
}

__host__ void EvaluateCompleteAutocorrelation_MultipleStreams(double **inputStreams, double **outputStreamCorrelations, unsigned int totalNumberOfThreads, unsigned int numbersToGeneratePerThread, bool verbose){
	for(unsigned int threadIndex=0; threadIndex<totalNumberOfThreads; ++threadIndex){
				
		if(verbose)
			cout << "@thread" << threadIndex << ":" << endl;

		EvaluateCompleteAutocorrelation_SingleStream(inputStreams[threadIndex], outputStreamCorrelations[threadIndex], numbersToGeneratePerThread, verbose);
	}
}
\end{lstlisting}

\subsection{\texttt{Path}}
\lipsum[1-3]

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/Path/Path.cuh}}]
#ifndef __Path_h__
#define __Path_h__

#include "../../InputStructures/InputMarketData/Input_market_data.cuh"
#include "../../InputStructures/InputOptionData/Input_option_data.cuh"

class Path{

	private:
		
		double _SpotPrice;		// The step (spotprice) required to generate the next one

		// Market data
		const double* _RiskFreeRate;
		const double* _Volatility;
		const double* _InitialPrice;

		// Base European option/contract data
		const char* _OptionType;
		const unsigned int* _NumberOfIntervals;
		const double* _TimeToMaturity;
		double _DeltaTime;
		
		// Plain vanilla option data
		const double* _StrikePrice;
		
		// Performance corridor data
		const double* _B;
		const double* _K;
		const double* _N;
		unsigned int _PerformanceCorridorBarrierCounter;
		
		// Boolean keeping track of negative prices in the Euler formula
		bool _NegativePrice;
		
		__device__ __host__ void CheckPerformanceCorridorCondition(double currentSpotPrice, double nextSpotPrice);
		
	public:

		__device__ __host__ Path();
		__device__ __host__ Path(const Input_market_data& market, const Input_option_data& option);
		__device__ __host__ ~Path() = default;

		__device__ __host__ void ResetToInitialState(const Input_market_data& market, const Input_option_data& option);
		__device__ __host__ void ResetToInitialState(const Path&);

		__device__ __host__ void EulerLogNormalStep(double gaussianRandomVariable);
		__device__ __host__ void ExactLogNormalStep(double gaussianRandomVariable);
		
		__device__ __host__ double GetSpotPrice() const;
		__device__ __host__ unsigned int GetPerformanceCorridorBarrierCounter() const;
		
		// Payoff evaluation
		__device__ __host__ double GetActualizedPayoff() const;
		
		// Check if a negative price happened in this run
		__device__ __host__ bool GetNegativePrice() const;

};

#endif
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/Path/Path.cu}}]
#include <cmath>	// sqrt, pow, fmax, log, exp, fabs

#include "Path.cuh"
#include "../../InputStructures/InputMarketData/Input_market_data.cuh"
#include "../../InputStructures/InputOptionData/Input_option_data.cuh"

using namespace std;

// Constructors
__device__ __host__ Path::Path(){
	this->_OptionType = NULL;
	this->_SpotPrice = 0.;
	this->_RiskFreeRate = NULL;
	this->_Volatility = NULL;
	this->_InitialPrice = NULL;
	this->_TimeToMaturity = NULL;
	this->_NumberOfIntervals = NULL;
	this->_DeltaTime = 0.;
	this->_StrikePrice = NULL;
	this->_B = NULL;
	this->_N = NULL;
	this->_K = NULL;
	this->_PerformanceCorridorBarrierCounter = 0;
	this->_NegativePrice = false;
}

__device__ __host__ Path::Path(const Input_market_data& market, const Input_option_data& option){
	this->_OptionType = &(option.OptionType);
	this->_SpotPrice = market.InitialPrice;
	this->_RiskFreeRate = &(market.RiskFreeRate);
	this->_Volatility = &(market.Volatility);
	this->_InitialPrice = &(market.InitialPrice);
	this->_TimeToMaturity = &(option.TimeToMaturity);
	this->_NumberOfIntervals = &(option.NumberOfIntervals);
	this->_DeltaTime = option.GetDeltaTime();
	this->_StrikePrice = &(option.StrikePrice);
	this->_B = &(option.B);
	this->_N = &(option.N);
	this->_K = &(option.K);
	this->_PerformanceCorridorBarrierCounter = 0;
	this->_NegativePrice = false;
}

// Public set methods
__device__ __host__ void Path::ResetToInitialState(const Input_market_data& market, const Input_option_data& option){
	this->_OptionType = &(option.OptionType);
	this->_SpotPrice = market.InitialPrice;
	this->_RiskFreeRate = &(market.RiskFreeRate);
	this->_Volatility = &(market.Volatility);
	this->_InitialPrice = &(market.InitialPrice);
	this->_TimeToMaturity = &(option.TimeToMaturity);
	this->_NumberOfIntervals = &(option.NumberOfIntervals);
	this->_DeltaTime = option.GetDeltaTime();
	this->_StrikePrice = &(option.StrikePrice);
	this->_B = &(option.B);
	this->_N = &(option.N);
	this->_K = &(option.K);
	this->_PerformanceCorridorBarrierCounter = 0;
	this->_NegativePrice = false;
}

__device__ __host__ void Path::ResetToInitialState(const Path& otherPath){
	this->_OptionType = otherPath._OptionType;
	this->_SpotPrice = otherPath._SpotPrice;
	this->_RiskFreeRate = otherPath._RiskFreeRate;
	this->_Volatility = otherPath._Volatility;
	this->_InitialPrice = otherPath._InitialPrice;
	this->_TimeToMaturity = otherPath._TimeToMaturity;
	this->_NumberOfIntervals = otherPath._NumberOfIntervals;
	this->_DeltaTime = otherPath._DeltaTime;
	this->_StrikePrice = otherPath._StrikePrice;
	this->_B = otherPath._B;
	this->_N = otherPath._N;
	this->_K = otherPath._K;
	this->_PerformanceCorridorBarrierCounter = otherPath._PerformanceCorridorBarrierCounter;
	this->_NegativePrice = otherPath._NegativePrice;
}

// Public get methods
__device__ __host__ double Path::GetSpotPrice() const{
	return this->_SpotPrice;
}

__device__ __host__ unsigned int Path::GetPerformanceCorridorBarrierCounter() const{
	return this->_PerformanceCorridorBarrierCounter;
}


// Euler and exact steps implementation
__device__ __host__ void Path::EulerLogNormalStep(double gaussianRandomVariable){
	double SpotPrice_i;		//The price at the next step
	SpotPrice_i = (this->_SpotPrice) *
	(1 + *(this->_RiskFreeRate) * this->_DeltaTime
	+ *(this->_Volatility) * sqrt(this->_DeltaTime) * gaussianRandomVariable);
	
	if(*(_OptionType) == 'e')
		this->CheckPerformanceCorridorCondition(this->_SpotPrice, SpotPrice_i);
		
	if(SpotPrice_i < 0)
		this->_NegativePrice = true;
	
	this->_SpotPrice = SpotPrice_i;
}

__device__ __host__ void Path::ExactLogNormalStep(double gaussianRandomVariable){
	double SpotPrice_i;		//The price at the next step
	SpotPrice_i = (this->_SpotPrice) * exp((*(this->_RiskFreeRate)
	- 0.5 * pow(*(this->_Volatility),2)) * this->_DeltaTime
	+ *(this->_Volatility) * gaussianRandomVariable * sqrt(this->_DeltaTime));
	
	if(*(_OptionType) == 'e')
		this->CheckPerformanceCorridorCondition(this->_SpotPrice, SpotPrice_i);
	
	this->_SpotPrice = SpotPrice_i;
}

// Check performance corridor condition
__device__ __host__ void Path::CheckPerformanceCorridorCondition(double currentSpotPrice, double nextSpotPrice){
	double modulusArgument = 1./(sqrt(this->_DeltaTime)) * log(nextSpotPrice / currentSpotPrice);
	double barrier = *(this->_B) * *(this->_Volatility);

	if(fabs(modulusArgument) < barrier)
		++(this->_PerformanceCorridorBarrierCounter);
}

// Evaluate atualized payoff
__device__ __host__ double Path::GetActualizedPayoff() const{
	double payoff;
	
	switch(*(this->_OptionType)){
		case 'f':
			payoff = this->_SpotPrice;
			break;
		
		case 'c':
			payoff = fmax(this->_SpotPrice - *(this->_StrikePrice), 0.);
			break;
		
		case 'p':
			payoff = fmax(*(this->_StrikePrice) - this->_SpotPrice, 0.);
			break;
		
		case 'e':
			payoff = *(this->_N) * fmax((static_cast<double>(this->_PerformanceCorridorBarrierCounter) / *(this->_NumberOfIntervals)) - *(this->_K), 0.);
			break;
			
		default:
			payoff = -10000.;
			break;
	}	
	
	return (payoff * exp(- *(this->_RiskFreeRate) * *(this->_TimeToMaturity)));
}

__device__ __host__ bool Path::GetNegativePrice() const{
	return this->_NegativePrice;
}
\end{lstlisting}

\subsection{\texttt{Statistics}}
\lipsum[1-3]

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/Statistics/Statistics.cuh}}]
#ifndef __Statistics_h__
#define __Statistics_h__

class Statistics{

	private:

		double _PayoffSum;
		double _SquaredPayoffSum;
		unsigned int _PayoffCounter;
		
		double _PayoffAverage;
		double _PayoffError;
		
		unsigned int _NegativePriceCounter;
		
	public:
	
		// Constructor and destructor
		__device__ __host__ Statistics();
		__device__ __host__ ~Statistics() = default;

		// Add argument and its square to the respective sums
		__device__ __host__ void AddPayoff(double payoff);
		
		// Reset sums and counter
		__device__ __host__ void ResetSums();
				
		// Return value of payoffSum or squaredPayoffSum (and respective counters)
		__device__ __host__ double GetPayoffSum() const;
		__device__ __host__ double GetSquaredPayoffSum() const;
		__device__ __host__ unsigned int GetPayoffCounter() const;
		
		// Evaluate average and error
		__device__ __host__ void EvaluateEstimatedPriceAndError();
		__device__ __host__ double GetPayoffAverage() const;
		__device__ __host__ double GetPayoffError() const;
		
		// Manage negative price counter
		__device__ __host__ unsigned int GetNegativePriceCounter() const;
		__device__ __host__ void IncreaseNegativePriceCounter();
		
		// Overload of += operator
		__host__ Statistics& operator+=(const Statistics&);	// Host-only because of isinf, at least for now

};

#endif
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/Statistics/Statistics.cu}}]
#include <cmath>	// pow, sqrt

#include "Statistics.cuh"

using namespace std;

// Constructor
__device__ __host__ Statistics::Statistics(){
	this->_PayoffSum = 0.;
	this->_SquaredPayoffSum = 0.;
	this->_PayoffCounter = 0;
	this->_NegativePriceCounter = 0;
}

// Public methods for addition
__device__ __host__ void Statistics::AddPayoff(double payoff){
	this->_PayoffSum += payoff;
	this->_SquaredPayoffSum += pow(payoff,2);
	++(this->_PayoffCounter);
}

// Public methods for sum resetting
__device__ __host__ void Statistics::ResetSums(){
	this->_PayoffSum = 0.;
	this->_SquaredPayoffSum = 0.;
	this->_PayoffCounter = 0;
	this->_NegativePriceCounter = 0;
}

// Public get methods
__device__ __host__ double Statistics::GetPayoffSum() const{
	return this->_PayoffSum;
}

__device__ __host__ double Statistics::GetSquaredPayoffSum() const{
	return this->_SquaredPayoffSum;
}

__device__ __host__ unsigned int Statistics::GetPayoffCounter() const{
	return this->_PayoffCounter;
}

// Average and error evaluation and output
__device__ __host__ void Statistics::EvaluateEstimatedPriceAndError(){
	this->_PayoffAverage = this->_PayoffSum / this->_PayoffCounter;
	this->_PayoffError = sqrt((this->_SquaredPayoffSum / this->_PayoffCounter - pow(this->_PayoffAverage,2))/ this->_PayoffCounter);
}

__device__ __host__ double Statistics::GetPayoffAverage() const{
	return this->_PayoffAverage;
}


__device__ __host__ double Statistics::GetPayoffError() const{
	return this->_PayoffError;
}

// Operator+= overload
__host__ Statistics& Statistics::operator+=(const Statistics& otherStatistics){

	if(std::isinf(otherStatistics.GetPayoffSum()) || std::isinf(otherStatistics.GetSquaredPayoffSum()))
		return *this;
	
	this->_PayoffSum += otherStatistics.GetPayoffSum();
	this->_SquaredPayoffSum += otherStatistics.GetSquaredPayoffSum();
	this->_PayoffCounter += otherStatistics.GetPayoffCounter();
	this->_NegativePriceCounter += otherStatistics.GetNegativePriceCounter();
	
	return *this;
}

// Manage negative price counter
__device__ __host__ unsigned int Statistics::GetNegativePriceCounter() const{
	return this->_NegativePriceCounter;
}

__device__ __host__ void Statistics::IncreaseNegativePriceCounter(){
	++(this->_NegativePriceCounter);
}
\end{lstlisting}

\subsection{\texttt{Data\_stream\_manager}}
\lipsum[1-3]

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/DataStreamManager/Data\_stream\_manager.cuh}}]
#ifndef _DATA__STREAM__MANAGER_H_
#define _DATA__STREAM__MANAGER_H_

#include <string>	// string

#include "../../InputStructures/InputGPUData/Input_gpu_data.cuh"
#include "../../InputStructures/InputMarketData/Input_market_data.cuh"
#include "../../InputStructures/InputMCData/Input_MC_data.cuh"
#include "../../InputStructures/InputOptionData/Input_option_data.cuh"
#include "../Statistics/Statistics.cuh"
#include "../../OutputStructures/OutputMCData/Output_MC_data.cuh"

class Data_stream_manager{
	
	private:
	
		std::string _InputFile;
	
	public:
	
		__host__ Data_stream_manager();
		__host__ Data_stream_manager(std::string inputFile);
		__host__ ~Data_stream_manager() = default;
		
		// Set input file
		__host__ void SetInputFile(std::string);
	
		// Input processing
		__host__ void ReadInputData(Input_gpu_data&, Input_option_data&, Input_market_data&, Input_MC_data&) const;
		__host__ void PrintInputData(const Input_gpu_data&, const Input_option_data&, const Input_market_data&, const Input_MC_data&) const;

		// Output processing
		__host__ void StoreOutputData(Output_MC_data&, const Statistics exactResults, const Statistics eulerResults, double elapsedTime, char hostOrDevice) const;
		__host__ void PrintOutputData(const Output_MC_data&) const;		
		
	
};

#endif
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/DataStreamManager/Data\_stream\_manager.cu}}]
#include <iostream>
#include <fstream>	// ifstream
#include <string>	// string, stoul, stod, at
#include <vector>	// vector
#include <iomanip>	// setprecision

#include "Data_stream_manager.cuh"
#include "../../InputStructures/InputGPUData/Input_gpu_data.cuh"
#include "../../InputStructures/InputMarketData/Input_market_data.cuh"
#include "../../InputStructures/InputMCData/Input_MC_data.cuh"
#include "../../InputStructures/InputOptionData/Input_option_data.cuh"
#include "../Statistics/Statistics.cuh"
#include "../../OutputStructures/OutputMCData/Output_MC_data.cuh"

using namespace std;

// Constructors
__host__ Data_stream_manager::Data_stream_manager(){
	_InputFile = "blank";
}
__host__ Data_stream_manager::Data_stream_manager(string inputFile){
	_InputFile = inputFile;
}

// Set input file
__host__ void Data_stream_manager::SetInputFile(string inputFile){
	_InputFile = inputFile;	
}

// Input processing
__host__ void Data_stream_manager::ReadInputData(Input_gpu_data& inputGPU, Input_option_data& inputOption, Input_market_data& inputMarket, Input_MC_data& inputMC) const{
	vector<string> inputDataVector;
	ifstream inputFileStream(_InputFile.c_str());
	string line;
	if(inputFileStream.is_open()){
		while(getline(inputFileStream, line))
			if(line[0] != '#')
				inputDataVector.push_back(line);
	}else
		cout << "ERROR: Unable to open file " << _InputFile << "." << endl;
		
	// Input GPU data
	inputGPU.NumberOfBlocks = stoul(inputDataVector[0]);

	// Input market data
	inputMarket.InitialPrice = stod(inputDataVector[1]);
	inputMarket.Volatility = stod(inputDataVector[2]);
	inputMarket.RiskFreeRate = stod(inputDataVector[3]);

	// Input option data
	inputOption.TimeToMaturity = stod(inputDataVector[4]);
	inputOption.NumberOfIntervals = stoul(inputDataVector[5]);
	inputOption.OptionType = inputDataVector[6].at(0);
	inputOption.StrikePrice = stod(inputDataVector[7]);
	inputOption.B = stod(inputDataVector[8]);
	inputOption.K = stod(inputDataVector[9]);
	inputOption.N = stod(inputDataVector[10]);

	// Input Monte Carlo data
	inputMC.NumberOfMCSimulations = stoul(inputDataVector[11]);
	inputMC.CpuOrGpu = inputDataVector[12].at(0);
	inputMC.GaussianOrBimodal = inputDataVector[13].at(0);
}

__host__ void Data_stream_manager::PrintInputData(const Input_gpu_data& inputGPU, const Input_option_data& inputOption, const Input_market_data& inputMarket, const Input_MC_data& inputMC) const{
	cout << endl << "###### INPUT DATA ######" << endl << endl;
	cout << "## GPU AND MC INPUT DATA ##" << endl;
	cout << "Number of blocks: " << inputGPU.NumberOfBlocks << endl;
	cout << "Number of threads per block: " << inputGPU.GetNumberOfThreadsPerBlock() << endl;
	cout << "Total number of threads: " << inputGPU.GetTotalNumberOfThreads() << endl; 
	cout << "Number of simulations: " << inputMC.NumberOfMCSimulations << endl;
	cout << "Number of simulations per thread (round-up): " << inputMC.GetNumberOfSimulationsPerThread(inputGPU) << endl;
	cout << "CPU v. GPU parameter: " << inputMC.CpuOrGpu << endl;
	cout << "Gaussian or bimodal random variable: " << inputMC.GaussianOrBimodal << endl;
	
	cout << "## MARKET DATA ##" << endl;
	cout << "Initial underlying price [USD]: " << inputMarket.InitialPrice << endl;
	cout << "Market volatility: " << inputMarket.Volatility << endl;
	cout << "Risk free rate: " << inputMarket.RiskFreeRate << endl; 
	
	cout << "## OPTION DATA ##" << endl;
	cout << "Option type: " << inputOption.OptionType << endl; 
	cout << "Time to option maturity [years]: " << inputOption.TimeToMaturity << endl;
	cout << "Number of intervals for Euler/exact step-by-step computation: " << inputOption.NumberOfIntervals << endl;
	cout << "Interval time [years]: " << inputOption.GetDeltaTime() << endl;
	switch(inputOption.OptionType){
		case 'p':
		case 'c':
			cout << "Option strike price [USD]: " << inputOption.StrikePrice << endl;
			break;
		
		case 'e':
			cout << "B: " << inputOption.B << endl;
			cout << "K [percentage]: " << inputOption.K << endl;
			cout << "N [EUR]: " << inputOption.N << endl;
		
		case 'f':
		default:
			break;
	}
	
	cout << endl;	
}

// Output processing
__host__ void Data_stream_manager::StoreOutputData(Output_MC_data& outputMC, const Statistics exactResults, const Statistics eulerResults, double elapsedTime, char hostOrDevice) const{
	outputMC.EstimatedPriceMCExact = exactResults.GetPayoffAverage();
	outputMC.ErrorMCExact = exactResults.GetPayoffError();
	outputMC.EstimatedPriceMCEuler = eulerResults.GetPayoffAverage();
	outputMC.ErrorMCEuler = eulerResults.GetPayoffError();
	outputMC.Tick = elapsedTime;
	outputMC.HostOrDevice = hostOrDevice;
	outputMC.NegativePriceCounter = eulerResults.GetNegativePriceCounter();
}

__host__ void Data_stream_manager::PrintOutputData(const Output_MC_data& outputMC) const{
	cout << endl << "## ";
	if(outputMC.HostOrDevice == 'h')
		cout << "HOST";
	else if(outputMC.HostOrDevice == 'd')
		cout << "DEVICE";
	else
		cout << "MISSINGNO.";
	
	cout << " OUTPUT MONTE CARLO DATA ##" << endl;
	cout << "Monte Carlo estimated price via exact formula [EUR]: " << setprecision(20) << outputMC.EstimatedPriceMCExact << endl;
	cout << "Monte Carlo estimated error via exact formula [EUR]: " << setprecision(20) << outputMC.ErrorMCExact << endl;
	cout << "Monte Carlo relative error via exact formula [EUR]: " << setprecision(20) << outputMC.GetRelativeErrorExact() << endl;
	cout << "Monte Carlo estimated price via Euler formula [EUR]: " << setprecision(20) << outputMC.EstimatedPriceMCEuler << endl;
	cout << "Monte Carlo estimated error via Euler formula [EUR]: " << setprecision(20) << outputMC.ErrorMCEuler << endl;
	cout << "Monte Carlo relative error via Euler formula [EUR]: " << setprecision(20) << outputMC.GetRelativeErrorEuler() << endl;
	cout << "Discrepancy between Euler and exact results [units of sigma]: " << setprecision(20) << outputMC.GetEulerToExactDiscrepancy() << endl;
	cout << "Computation time [ms]: " << setprecision(20) << outputMC.Tick << endl;
	cout << "Negative price counter: " << outputMC.NegativePriceCounter << endl;
	
	cout << endl;	
}
\end{lstlisting}

\subsection{\texttt{Support\_functions}}
\lipsum[1-3]

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/SupportFunctions/Support\_functions.cuh}}]
#ifndef _SUPPORT_FUNCTIONS_H_
#define _SUPPORT_FUNCTIONS_H_

#include <vector>	// vector
#include <string>	// string

#include "../../InputStructures/InputGPUData/Input_gpu_data.cuh"
#include "../../InputStructures/InputMarketData/Input_market_data.cuh"
#include "../../InputStructures/InputMCData/Input_MC_data.cuh"
#include "../../InputStructures/InputOptionData/Input_option_data.cuh"
#include "../DataStreamManager/Data_stream_manager.cuh"
#include "../Statistics/Statistics.cuh"

// Main evaluators (host-device paradigm)
__host__ void OptionPricingEvaluator_Host(Input_gpu_data, Input_option_data, Input_market_data, Input_MC_data, Statistics* exactOutputs, Statistics* eulerOutputs, unsigned int seed);
__host__ __device__ void OptionPricingEvaluator_HostDev(Input_gpu_data, Input_option_data, Input_market_data, Input_MC_data, Statistics* exactOutputs, Statistics* eulerOutputs, unsigned int seed, unsigned int threadNumber);
__global__ void OptionPricingEvaluator_Global(Input_gpu_data, Input_option_data, Input_market_data, Input_MC_data, Statistics* exactOutputs, Statistics* eulerOutputs, unsigned int seed);

// CPU and GPU algorithms
__host__ void CPUOptionPricingMonteCarloAlgorithm(Data_stream_manager, Input_gpu_data, Input_option_data, Input_market_data, Input_MC_data, unsigned int seed);
__host__ void GPUOptionPricingMonteCarloAlgorithm(Data_stream_manager, Input_gpu_data, Input_option_data, Input_market_data, Input_MC_data, unsigned int seed);

#endif
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/SupportFunctions/Support\_functions.cu}}]
#include <iostream>

#include "Support_functions.cuh"
#include "../../InputStructures/InputGPUData/Input_gpu_data.cuh"
#include "../../InputStructures/InputMarketData/Input_market_data.cuh"
#include "../../InputStructures/InputMCData/Input_MC_data.cuh"
#include "../../InputStructures/InputOptionData/Input_option_data.cuh"
#include "../DataStreamManager/Data_stream_manager.cuh"
#include "../Path/Path.cuh"
#include "../Statistics/Statistics.cuh"
#include "../RandomGenerator/RNG.cuh"
#include "../../OutputStructures/OutputMCData/Output_MC_data.cuh"

using namespace std;

// Main evaluators
__host__ __device__ void OptionPricingEvaluator_HostDev(Input_gpu_data inputGPU, Input_option_data option, Input_market_data market, Input_MC_data inputMC, Statistics* exactOutputs, Statistics* eulerOutputs, unsigned int seed, unsigned int threadNumber){
	
	unsigned int numberOfPathsPerThread = inputMC.GetNumberOfSimulationsPerThread(inputGPU);
	unsigned int numberOfIntervals = option.NumberOfIntervals;
	unsigned int totalNumberOfSimulations = inputMC.NumberOfMCSimulations;

	RNG *supportGenerator = new RNG_Tausworthe(seed+threadNumber);
	RNG *mainGenerator = new RNG_CombinedGenerator;
	mainGenerator->SetInternalState(supportGenerator);
	
	// Dummy variables to reduce memory accesses
	Path exactPath, eulerPath;

	// Cycling through paths, overwriting the same dummy path with the same template path
	for(unsigned int pathNumber=0; pathNumber<numberOfPathsPerThread; ++pathNumber){
		
		// Check if we're not overflowing. Since we decide a priori the number of simulations, some threads will inevitably work less
		if(numberOfPathsPerThread * threadNumber + pathNumber < totalNumberOfSimulations){
			exactPath.ResetToInitialState(market, option);
			eulerPath.ResetToInitialState(market, option);

			// Cycling through steps in each path
			for(unsigned int stepNumber=0; stepNumber<numberOfIntervals; ++stepNumber){
				if(inputMC.GaussianOrBimodal == 'g'){
					exactPath.ExactLogNormalStep(mainGenerator->GetGauss());
					eulerPath.EulerLogNormalStep(mainGenerator->GetGauss());
				}else if(inputMC.GaussianOrBimodal == 'b'){
					exactPath.ExactLogNormalStep(mainGenerator->GetBimodal());
					eulerPath.EulerLogNormalStep(mainGenerator->GetBimodal());
				}
			}

			exactOutputs[threadNumber].AddPayoff(exactPath.GetActualizedPayoff());
			eulerOutputs[threadNumber].AddPayoff(eulerPath.GetActualizedPayoff());
			
			if(eulerPath.GetNegativePrice())
				eulerOutputs[threadNumber].IncreaseNegativePriceCounter();
		}
	}
}

__host__ void OptionPricingEvaluator_Host(Input_gpu_data inputGPU, Input_option_data option, Input_market_data market, Input_MC_data inputMC, Statistics* exactOutputs, Statistics* eulerOutputs, unsigned int seed){
	unsigned int totalNumberOfThreads = inputGPU.GetTotalNumberOfThreads();
	
	for(unsigned int threadNumber=0; threadNumber<totalNumberOfThreads; ++threadNumber)
		OptionPricingEvaluator_HostDev(inputGPU, option, market, inputMC, exactOutputs, eulerOutputs, seed, threadNumber);
}

__global__ void OptionPricingEvaluator_Global(Input_gpu_data inputGPU, Input_option_data option, Input_market_data market, Input_MC_data inputMC, Statistics* exactOutputs, Statistics* eulerOutputs, unsigned int seed){
	unsigned int threadNumber = threadIdx.x + blockDim.x * blockIdx.x;
	OptionPricingEvaluator_HostDev(inputGPU, option, market, inputMC, exactOutputs, eulerOutputs, seed, threadNumber);
}

// CPU and GPU algorithms
__host__ void CPUOptionPricingMonteCarloAlgorithm(Data_stream_manager streamManager, Input_gpu_data inputGPU, Input_option_data inputOption, Input_market_data inputMarket, Input_MC_data inputMC, unsigned int seed){
	unsigned int numberOfThreadsPerBlock = inputGPU.GetNumberOfThreadsPerBlock();
	unsigned int totalNumberOfThreads = inputGPU.GetTotalNumberOfThreads();
	unsigned int numberOfSimulationsPerThread = inputMC.GetNumberOfSimulationsPerThread(inputGPU);

	// Time events creation
	cudaEvent_t cpuEventStart, cpuEventStop;
	float cpuElapsedTime;
	cudaEventCreate(&cpuEventStart);
	cudaEventCreate(&cpuEventStop);
	
	// Output arrays
	Statistics *cpu_exactOutputs = new Statistics[totalNumberOfThreads];
	Statistics *cpu_eulerOutputs = new Statistics[totalNumberOfThreads];
	
	cudaEventRecord(cpuEventStart,0);
	
	// Simulation of device path generation
	cout << endl << "Beginning device simulation through CPU..." << endl;
	OptionPricingEvaluator_Host(inputGPU, inputOption, inputMarket, inputMC, cpu_exactOutputs, cpu_eulerOutputs, seed);
	
	cudaEventRecord(cpuEventStop,0);
	cudaEventSynchronize(cpuEventStop);
	cudaEventElapsedTime(&cpuElapsedTime, cpuEventStart, cpuEventStop);
	
	// Output computation
	Statistics cpu_exactResults;
	Statistics cpu_eulerResults;

	for(unsigned int threadNumber=0; threadNumber<totalNumberOfThreads; ++threadNumber){
		cpu_exactResults += cpu_exactOutputs[threadNumber];
		cpu_eulerResults += cpu_eulerOutputs[threadNumber];
	}

	cpu_exactResults.EvaluateEstimatedPriceAndError();
	cpu_eulerResults.EvaluateEstimatedPriceAndError();

	// Global output MC
	Output_MC_data cpu_outputMC;
	streamManager.StoreOutputData(cpu_outputMC, cpu_exactResults, cpu_eulerResults, cpuElapsedTime, 'h');
	streamManager.PrintOutputData(cpu_outputMC);
	
	// Trash bin section, where segfaults come to die
	delete[] cpu_exactOutputs;
	delete[] cpu_eulerOutputs;
	cudaEventDestroy(cpuEventStart);
	cudaEventDestroy(cpuEventStop);	
}

__host__ void GPUOptionPricingMonteCarloAlgorithm(Data_stream_manager streamManager, Input_gpu_data inputGPU, Input_option_data inputOption, Input_market_data inputMarket, Input_MC_data inputMC, unsigned int seed){
	unsigned int numberOfThreadsPerBlock = inputGPU.GetNumberOfThreadsPerBlock();
	unsigned int totalNumberOfThreads = inputGPU.GetTotalNumberOfThreads();
	unsigned int numberOfSimulationsPerThread = inputMC.GetNumberOfSimulationsPerThread(inputGPU);

	// Time events creation
	cudaEvent_t gpuEventStart, gpuEventStop;
	float gpuElapsedTime;
	cudaEventCreate(&gpuEventStart);
	cudaEventCreate(&gpuEventStop);

	// Output arrays
	Statistics *gpu_exactOutputs = new Statistics[totalNumberOfThreads];
	Statistics *gpu_eulerOutputs = new Statistics[totalNumberOfThreads];
	
	cudaEventRecord(gpuEventStart,0);

	// Memory allocation on GPU
	Statistics *device_gpu_exactOutputs;
	Statistics *device_gpu_eulerOutputs;
	
	cudaMalloc((void **)&device_gpu_exactOutputs, totalNumberOfThreads*sizeof(Statistics));
	cudaMalloc((void **)&device_gpu_eulerOutputs, totalNumberOfThreads*sizeof(Statistics));
	
	cudaMemcpy(device_gpu_exactOutputs, gpu_exactOutputs, totalNumberOfThreads*sizeof(Statistics), cudaMemcpyHostToDevice);
	cudaMemcpy(device_gpu_eulerOutputs, gpu_eulerOutputs, totalNumberOfThreads*sizeof(Statistics), cudaMemcpyHostToDevice);
	
	// Generation of paths
	cout << endl << "Beginning GPU computation..." << endl;
	OptionPricingEvaluator_Global<<<inputGPU.NumberOfBlocks,numberOfThreadsPerBlock>>>(inputGPU, inputOption, inputMarket, inputMC, device_gpu_exactOutputs, device_gpu_eulerOutputs, seed);
	
	// The memories are coming back
	cudaMemcpy(gpu_exactOutputs, device_gpu_exactOutputs, totalNumberOfThreads*sizeof(Statistics), cudaMemcpyDeviceToHost);
	cudaMemcpy(gpu_eulerOutputs, device_gpu_eulerOutputs, totalNumberOfThreads*sizeof(Statistics), cudaMemcpyDeviceToHost);

	cudaFree(device_gpu_exactOutputs);
	cudaFree(device_gpu_eulerOutputs);
	
	cudaEventRecord(gpuEventStop,0);
	cudaEventSynchronize(gpuEventStop);
	cudaEventElapsedTime(&gpuElapsedTime, gpuEventStart, gpuEventStop);
	
	// Output computation
	Statistics gpu_exactResults;
	Statistics gpu_eulerResults;

	for(unsigned int threadNumber=0; threadNumber<totalNumberOfThreads; ++threadNumber){
		gpu_exactResults += gpu_exactOutputs[threadNumber];
		gpu_eulerResults += gpu_eulerOutputs[threadNumber];
	}

	gpu_exactResults.EvaluateEstimatedPriceAndError();
	gpu_eulerResults.EvaluateEstimatedPriceAndError();

	// Global output MC
	Output_MC_data gpu_outputMC;
	streamManager.StoreOutputData(gpu_outputMC, gpu_exactResults, gpu_eulerResults, gpuElapsedTime, 'd');
	streamManager.PrintOutputData(gpu_outputMC);
	
	// Trash bin section, where segfaults come to die
	delete[] gpu_exactOutputs;
	delete[] gpu_eulerOutputs;
	cudaEventDestroy(gpuEventStart);
	cudaEventDestroy(gpuEventStop);
}
\end{lstlisting}

\section{Eseguibili}
\lipsum[1]

\subsection{Controlli sui numeri pseudocasuali}
\lipsum[1-3]

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/RandomGenerator/OutputTest.cu}}]
//
//	OUTPUT & CPU/GPU COMPARISON TEST
//
//	Tests correct generation of pseudorandom numbers and compares CPU to GPU output with same seed.
//

#include <iostream>
#include <ctime>		// time(NULL) for seed
#include <climits>		// UINT_MAX
#include <cmath>		// ceil

#include "RNG.cuh"

using namespace std;

__global__ void RNGen_Global(unsigned int *unsignedNumbers, double *uniformNumbers, double *gaussianNumbers, double *bimodalNumbers, unsigned int totalNumbersToGenerate, unsigned int numbersToGeneratePerThread, unsigned int seed);
__host__ __device__ void RNGen_HostDev(unsigned int *unsignedNumbers, double *uniformNumbers, double *gaussianNumbers, double *bimodalNumbers, unsigned int totalNumbersToGenerate, unsigned int numbersToGeneratePerThread, unsigned int seed, unsigned int threadNumber);
__host__ void RNGen_Host(unsigned int numberOfBlocks, unsigned int numberOfThreadsPerBlock, unsigned int *unsignedNumbers, double *uniformNumbers, double *gaussianNumbers, double *bimodalNumbers, unsigned int totalNumbersToGenerate, unsigned int numbersToGeneratePerThread, unsigned int seed);

bool AreSame(unsigned int, unsigned int);
bool AreSame(double, double);

int main(){

	unsigned int numberOfBlocks = 10;
	unsigned int numberOfThreadsPerBlock = 512;
	unsigned int totalNumberOfThreads = numberOfBlocks * numberOfThreadsPerBlock;
	unsigned int totalNumbersToGenerate = 500000;
	
	unsigned int seed;	
	
	do
		seed = time(NULL);
	while(seed < 129 || seed > UINT_MAX - totalNumberOfThreads);

	unsigned int numbersToGeneratePerThread = ceil(static_cast<double>(totalNumbersToGenerate) / totalNumberOfThreads);
	cout << "Total numbers to generate: " << totalNumbersToGenerate << endl;
	cout << "Total number of threads: " << totalNumberOfThreads << endl;
	cout << "Total numbers to generate per thread: " << numbersToGeneratePerThread << endl;

	// CPU-side results
	unsigned int *cpu_unsignedNumbers = new unsigned int[totalNumbersToGenerate];
	double *cpu_uniformNumbers = new double[totalNumbersToGenerate];
	double *cpu_gaussianNumbers = new double[totalNumbersToGenerate];
	double *cpu_bimodalNumbers = new double[totalNumbersToGenerate];

	// GPU-side results
	unsigned int *gpu_unsignedNumbers = new unsigned int[totalNumbersToGenerate];
	double *gpu_uniformNumbers = new double[totalNumbersToGenerate];
	double *gpu_gaussianNumbers = new double[totalNumbersToGenerate];
	double *gpu_bimodalNumbers = new double[totalNumbersToGenerate];
	
	////////////// HOST-SIDE GENERATOR //////////////
	RNGen_Host(numberOfBlocks, numberOfThreadsPerBlock, cpu_unsignedNumbers, cpu_uniformNumbers, cpu_gaussianNumbers, cpu_bimodalNumbers, totalNumbersToGenerate, numbersToGeneratePerThread, seed);
	/////////////////////////////////////////////////

	////////////// DEVICE-SIDE GENERATOR //////////////
	unsigned int *dev_gpu_unsignedNumbers;
	double *dev_gpu_uniformNumbers, *dev_gpu_gaussianNumbers, *dev_gpu_bimodalNumbers;
	
	cudaMalloc( (void **)&dev_gpu_unsignedNumbers, totalNumbersToGenerate*sizeof(unsigned int) );
	cudaMalloc( (void **)&dev_gpu_uniformNumbers, totalNumbersToGenerate*sizeof(double) );
	cudaMalloc( (void **)&dev_gpu_gaussianNumbers, totalNumbersToGenerate*sizeof(double) );
	cudaMalloc( (void **)&dev_gpu_bimodalNumbers, totalNumbersToGenerate*sizeof(double) );
	
	RNGen_Global<<<numberOfBlocks,numberOfThreadsPerBlock>>>(dev_gpu_unsignedNumbers, dev_gpu_uniformNumbers, dev_gpu_gaussianNumbers, dev_gpu_bimodalNumbers, totalNumbersToGenerate, numbersToGeneratePerThread, seed);

	cudaMemcpy(gpu_unsignedNumbers, dev_gpu_unsignedNumbers, totalNumbersToGenerate*sizeof(unsigned int), cudaMemcpyDeviceToHost);
	cudaMemcpy(gpu_uniformNumbers, dev_gpu_uniformNumbers, totalNumbersToGenerate*sizeof(double), cudaMemcpyDeviceToHost);
	cudaMemcpy(gpu_gaussianNumbers, dev_gpu_gaussianNumbers, totalNumbersToGenerate*sizeof(double), cudaMemcpyDeviceToHost);
	cudaMemcpy(gpu_bimodalNumbers, dev_gpu_bimodalNumbers, totalNumbersToGenerate*sizeof(double), cudaMemcpyDeviceToHost);

	cudaFree(dev_gpu_unsignedNumbers);
	cudaFree(dev_gpu_uniformNumbers);
	cudaFree(dev_gpu_gaussianNumbers);
	cudaFree(dev_gpu_bimodalNumbers);
	///////////////////////////////////////////////////
	
	////////////// TESTS //////////////

	cout << endl << "############### OUTPUT NUMBERS ################" << endl;
	
	cout << endl << "CPU: " << endl;
	cout << "thread\t unsigned\t uniform\t gauss\t bimodal" << endl;
	for(int randomNumber=0; randomNumber<5; ++randomNumber)
		cout << randomNumber << "\t" << cpu_unsignedNumbers[randomNumber] << "\t" << cpu_uniformNumbers[randomNumber] << "\t" << cpu_gaussianNumbers[randomNumber] << "\t" << cpu_bimodalNumbers[randomNumber] << endl;;
	cout << ". . ." << endl;	
	for(int randomNumber=totalNumbersToGenerate-5; randomNumber<totalNumbersToGenerate; ++randomNumber)
		cout << randomNumber << "\t" << cpu_unsignedNumbers[randomNumber] << "\t" << cpu_uniformNumbers[randomNumber] << "\t" << cpu_gaussianNumbers[randomNumber] << "\t" << cpu_bimodalNumbers[randomNumber] << endl;
		
	cout << endl << "GPU: " << endl;
	cout << "thread\t unsigned\t uniform\t gauss" << endl;
	for(int randomNumber=0; randomNumber<5; ++randomNumber)
		cout << randomNumber << "\t" << gpu_unsignedNumbers[randomNumber] << "\t" << gpu_uniformNumbers[randomNumber] << "\t" << gpu_gaussianNumbers[randomNumber] << "\t" << gpu_bimodalNumbers[randomNumber] << endl;
	cout << ". . ." << endl;	
	for(int randomNumber=totalNumbersToGenerate-5; randomNumber<totalNumbersToGenerate; ++randomNumber)
		cout << randomNumber << "\t" << gpu_unsignedNumbers[randomNumber] << "\t" << gpu_uniformNumbers[randomNumber] << "\t" << gpu_gaussianNumbers[randomNumber] << "\t" << gpu_bimodalNumbers[randomNumber] << endl;

	cout << endl << "############### GPU-CPU COMPARISON ################" << endl << endl;
	
	bool gpuCpuComparison = true;
	for(int randomNumber=0; randomNumber<totalNumbersToGenerate; ++randomNumber){
		if(!AreSame(gpu_unsignedNumbers[randomNumber], cpu_unsignedNumbers[randomNumber])){
			gpuCpuComparison = false;
			cout << "FAILED@step " << randomNumber << ":\t" << gpu_unsignedNumbers[randomNumber] << "\t" << cpu_unsignedNumbers[randomNumber] << endl;
		}
		
		if(!AreSame(gpu_uniformNumbers[randomNumber], cpu_uniformNumbers[randomNumber])){
			gpuCpuComparison = false;
			cout << "FAILED@step " << randomNumber << ":\t" << gpu_uniformNumbers[randomNumber] << "\t" << cpu_uniformNumbers[randomNumber] << endl;
		}
		
		if(!AreSame(gpu_gaussianNumbers[randomNumber], cpu_gaussianNumbers[randomNumber])){
			gpuCpuComparison = false;
			cout << "FAILED@step " << randomNumber << ":\t" << gpu_gaussianNumbers[randomNumber] << "\t" << cpu_gaussianNumbers[randomNumber] << endl;
		}
		
		if(!AreSame(gpu_bimodalNumbers[randomNumber], cpu_bimodalNumbers[randomNumber])){
			gpuCpuComparison = false;
			cout << "FAILED@step " << randomNumber << ":\t" << gpu_bimodalNumbers[randomNumber] << "\t" << cpu_bimodalNumbers[randomNumber] << endl;
		}
	}
	
	if(gpuCpuComparison)
		cout << "Test PASSED!" << endl;
	else
		cout << "Test failed..." << endl;

	delete[] cpu_unsignedNumbers;
	delete[] cpu_uniformNumbers;
	delete[] cpu_gaussianNumbers;
	delete[] cpu_bimodalNumbers;
	
	delete[] gpu_unsignedNumbers;
	delete[] gpu_uniformNumbers;
	delete[] gpu_gaussianNumbers;
	delete[] gpu_bimodalNumbers;

	return 0;

}

/////////////////////////////////////////////
///////////////// FUNCTIONS /////////////////
/////////////////////////////////////////////

__global__ void RNGen_Global(unsigned int *unsignedNumbers, double *uniformNumbers, double *gaussianNumbers, double *bimodalNumbers, unsigned int totalNumbersToGenerate, unsigned int numbersToGeneratePerThread, unsigned int seed){
	unsigned int threadNumber = threadIdx.x + blockDim.x * blockIdx.x;
	RNGen_HostDev(unsignedNumbers, uniformNumbers, gaussianNumbers, bimodalNumbers, totalNumbersToGenerate, numbersToGeneratePerThread, seed, threadNumber);
}

__host__ __device__ void RNGen_HostDev(unsigned int *unsignedNumbers, double *uniformNumbers, double *gaussianNumbers, double *bimodalNumbers, unsigned int totalNumbersToGenerate, unsigned int numbersToGeneratePerThread, unsigned int seed, unsigned int threadNumber){
	
	RNG *supportGenerator = new RNG_Tausworthe(seed+threadNumber);
	
	RNG *generator = new RNG_CombinedGenerator;
	generator->SetInternalState(supportGenerator);
	
	unsigned int unsignedNumber;
	double gaussian, uniform, bimodal;

	for(unsigned int RNGNumber=0; RNGNumber<numbersToGeneratePerThread; ++RNGNumber){		
		if(numbersToGeneratePerThread*threadNumber+RNGNumber < totalNumbersToGenerate){
			unsignedNumber = generator->GetUnsignedInt();
			unsignedNumbers[numbersToGeneratePerThread*threadNumber+RNGNumber] = unsignedNumber;

			uniform = generator->GetUniform();
			uniformNumbers[numbersToGeneratePerThread*threadNumber+RNGNumber] = uniform;
		
			gaussian = generator->GetGauss();
			gaussianNumbers[numbersToGeneratePerThread*threadNumber+RNGNumber] = gaussian;
			
			bimodal = generator->GetBimodal();
			bimodalNumbers[numbersToGeneratePerThread*threadNumber+RNGNumber] = bimodal;
		}
	}
}

__host__ void RNGen_Host(unsigned int numberOfBlocks, unsigned int numberOfThreadsPerBlock, unsigned int *unsignedNumbers, double *uniformNumbers, double *gaussianNumbers, double *bimodalNumbers, unsigned int totalNumbersToGenerate, unsigned int numbersToGeneratePerThread, unsigned int seed){
	
	for(unsigned int threadNumber=0; threadNumber<numberOfBlocks*numberOfThreadsPerBlock; ++threadNumber)
			RNGen_HostDev(unsignedNumbers, uniformNumbers, gaussianNumbers, bimodalNumbers, totalNumbersToGenerate, numbersToGeneratePerThread, seed, threadNumber);
}

bool AreSame(unsigned int a, unsigned int b){
	unsigned int diff = a - b;
	double epsilon = 0.0001;	// 0.01% difference
	return (fabs(static_cast<double>(diff) / a) < epsilon);
}
bool AreSame(double a, double b){
	double diff = a - b;
	double epsilon = 0.0001;	// 0.01% difference
	return (fabs(diff / a) < epsilon);	
}
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/RandomGenerator/CorrelationTest.cu}}]
//
//	INTER- AND INTRA-STREAM CORRELATION TEST
//
//	Tests correlation of random generated numbers within single streams
//	as well as across all streams.
//

#include <iostream>
#include <ctime>		// time(NULL) for seed
#include <climits>		// UINT_MAX

#include "RNG.cuh"
#include "CorrelationToolbox.cuh"

using namespace std;

int main(){
	
	// Verbosities
	bool intraStreamAverageVerbosity = true;
	bool intraStreamVarianceVerbosity = true;
	bool intraStreamKurtosisVerbosity = true;
	bool intraStreamAutocorrelationVerbosity = true;
	
	bool interStreamAverageVerbosity = true;
	bool interStreamVarianceVerbosity = true;
	bool interStreamKurtosisVerbosity = true;
	bool interStreamAutocorrelationVerbosity = true;
	
	
	unsigned int numberOfBlocks = 1;
	unsigned int numberOfThreadsPerBlock = 512;
	unsigned int totalNumberOfThreads = numberOfBlocks * numberOfThreadsPerBlock;
	unsigned int numbersToGeneratePerThread = 1000;
	unsigned int totalNumbersToGenerate = totalNumberOfThreads * numbersToGeneratePerThread;

	cout << "Total numbers to generate: " << totalNumbersToGenerate << endl;
	cout << "Total number of threads: " << totalNumberOfThreads << endl;
	cout << "Total numbers to generate per thread: " << numbersToGeneratePerThread << endl;
	
	double **uniformNumbers = new double*[totalNumberOfThreads];
	double **gaussianNumbers = new double*[totalNumberOfThreads];
	
	for(unsigned int threadIndex=0; threadIndex<totalNumberOfThreads; ++threadIndex){
		uniformNumbers[threadIndex] = new double[numbersToGeneratePerThread];
		gaussianNumbers[threadIndex] = new double[numbersToGeneratePerThread];
	}

	// Seed for Tausworthe support generator
	unsigned int seed;	
	do
		seed = time(NULL);
	while(seed < 129 || seed > UINT_MAX - totalNumberOfThreads);
	

	RandomNumberGeneration(numberOfBlocks, numberOfThreadsPerBlock, uniformNumbers, gaussianNumbers, totalNumbersToGenerate, numbersToGeneratePerThread, seed);
	
	cout << endl <<  "############### INTRA-STREAM TEST ###############" << endl;
	
	// Average, exp. 0.5 for uniform numbers, 0 for gaussian numbers
	double *uniformAverages = new double[totalNumberOfThreads];
	double *gaussAverages = new double[totalNumberOfThreads];
	
	if(intraStreamAverageVerbosity)
		cout << endl << "Uniform averages (exp. 0.5):" << endl;
	EvaluateAverage_MultipleStreams(uniformNumbers, uniformAverages, totalNumberOfThreads, numbersToGeneratePerThread, intraStreamAverageVerbosity);
	
	if(intraStreamAverageVerbosity)
		cout << endl << "Gaussian averages (exp. 0):" << endl;
	EvaluateAverage_MultipleStreams(gaussianNumbers, gaussAverages, totalNumberOfThreads, numbersToGeneratePerThread, intraStreamAverageVerbosity);

	// Gaussian variance, exp. 1
	double *gaussVariances = new double[totalNumberOfThreads];
	if(intraStreamVarianceVerbosity)
		cout << endl << "Gaussian variances (exp. 1):" << endl;
	EvaluateVariance_MultipleStreams(gaussianNumbers, gaussAverages, gaussVariances, totalNumberOfThreads, numbersToGeneratePerThread, intraStreamVarianceVerbosity);
	
	// Gaussian kurtosis, exp. 3
	double *gaussKurtosises = new double[totalNumberOfThreads];
	if(intraStreamKurtosisVerbosity)
		cout << endl << "Gaussian kurtosises (exp. 3):" << endl;
	EvaluateKurtosis_MultipleStreams(gaussianNumbers, gaussAverages, gaussVariances, gaussKurtosises, totalNumberOfThreads, numbersToGeneratePerThread, intraStreamKurtosisVerbosity);

	// Autocorrelation i/i+k, exp. 0.25 for uniform numbers, 0 for gaussian numbers
	double **uniformCorrelations = new double*[totalNumberOfThreads];
	double **gaussCorrelations = new double*[totalNumberOfThreads];
	
	for(unsigned int threadIndex=0; threadIndex<totalNumberOfThreads; ++threadIndex){
		// One component for each autocorrelation offset k (as in xi*xi+k)
		// which runs from 1 to numbersToGeneratePerThread-1
		uniformCorrelations[threadIndex] = new double[numbersToGeneratePerThread-2];	
		gaussCorrelations[threadIndex] = new double[numbersToGeneratePerThread-2];
	}

	if(intraStreamAutocorrelationVerbosity)
		cout << endl << "Uniform autocorrelations i/i+k (exp. 0.25):" << endl;
	EvaluateCompleteAutocorrelation_MultipleStreams(uniformNumbers, uniformCorrelations, totalNumberOfThreads, numbersToGeneratePerThread, intraStreamAutocorrelationVerbosity);
	
	if(intraStreamAutocorrelationVerbosity)
		cout << endl << "Gaussian autocorrelations i/i+k (exp. 0):" << endl;
	EvaluateCompleteAutocorrelation_MultipleStreams(gaussianNumbers, gaussCorrelations, totalNumberOfThreads, numbersToGeneratePerThread, intraStreamAutocorrelationVerbosity);

///////////////////////////////////////////////////////////////////////////////////////////////////////

	cout << endl <<  "############### INTER-STREAM TEST ###############" << endl;
	// Build the Super Stream, i.e. the combination of all streams of RNGs
	double *superStreamOfUniformNumbers = new double[totalNumbersToGenerate];
	double *superStreamOfGaussianNumbers = new double[totalNumbersToGenerate];
	
	for(unsigned int RNGIndex=0; RNGIndex<numbersToGeneratePerThread; ++RNGIndex){
		for(unsigned int threadIndex=0; threadIndex<totalNumberOfThreads; ++threadIndex){
			superStreamOfUniformNumbers[RNGIndex*totalNumberOfThreads+threadIndex] = uniformNumbers[threadIndex][RNGIndex];
			superStreamOfGaussianNumbers[RNGIndex*totalNumberOfThreads+threadIndex] = gaussianNumbers[threadIndex][RNGIndex];
		}
	}
	
	// Average, exp. 0.5 for uniform numbers, 0 for gaussian numbers
	double superStreamUniformAverage = GetAverage_SingleStream(superStreamOfUniformNumbers, totalNumbersToGenerate);
	double superStreamGaussAverage = GetAverage_SingleStream(superStreamOfGaussianNumbers, totalNumbersToGenerate);
	if(interStreamAverageVerbosity){
		cout << "Uniform super stream avg (exp. 0.5):\t" << superStreamUniformAverage << endl;
		cout << "Gaussian super stream avg (exp. 0):\t" << superStreamGaussAverage << endl;
	}
	
	// Gaussian variance, exp. 1
	double superStreamGaussianVariance = GetVariance_SingleStream(superStreamOfGaussianNumbers, superStreamGaussAverage, totalNumbersToGenerate);
	if(interStreamVarianceVerbosity){
		cout << "Gaussian super stream variance (exp. 1):\t" << superStreamGaussianVariance << endl;
	}
	
	// Gaussian kurtosis, exp. 3
	double superStreamGaussianKurtosis = GetKurtosis_SingleStream(superStreamOfGaussianNumbers, superStreamGaussAverage, superStreamGaussianVariance, totalNumbersToGenerate);
	if(interStreamKurtosisVerbosity){
		cout << "Gaussian super stream kurtosis (exp. 3):\t" << superStreamGaussianKurtosis << endl;
	}
	
	// Autocorrelation i/i+k, exp. 0.25 for uniform numbers, 0 for gaussian numbers
	double *superStreamUniformCorrelations = new double[totalNumbersToGenerate-2];
	double *superStreamGaussianCorrelations = new double[totalNumbersToGenerate-2];
	if(interStreamAutocorrelationVerbosity)
		cout << "Uniform super stream autocorrelation (exp. 0.25):" << endl;
	EvaluateCompleteAutocorrelation_SingleStream(superStreamOfUniformNumbers, superStreamUniformCorrelations, totalNumbersToGenerate, interStreamAutocorrelationVerbosity);
	if(interStreamAutocorrelationVerbosity)
		cout << "Gaussian super stream autocorrelation (exp. 0):" << endl;
	EvaluateCompleteAutocorrelation_SingleStream(superStreamOfGaussianNumbers, superStreamGaussianCorrelations, totalNumbersToGenerate, interStreamAutocorrelationVerbosity);

/////////////////////////////////////////

	// Quite a lot of space to free up
	delete[] uniformAverages;
	delete[] gaussAverages;
	delete[] gaussVariances;
	delete[] gaussKurtosises;

	for(unsigned int threadIndex=0; threadIndex<totalNumberOfThreads; ++threadIndex){
		delete[] uniformCorrelations[threadIndex];
		delete[] gaussCorrelations[threadIndex];
		delete[] uniformNumbers[threadIndex];
		delete[] gaussianNumbers[threadIndex];
	}
	
	delete[] uniformCorrelations;
	delete[] gaussCorrelations;
	delete[] superStreamUniformCorrelations;
	delete[] superStreamGaussianCorrelations;

	delete[] superStreamOfUniformNumbers;
	delete[] superStreamOfGaussianNumbers;
	delete[] uniformNumbers;
	delete[] gaussianNumbers;
	
	return 0;

}
\end{lstlisting}

\subsection{Confronto con i risultati analitici}
\lipsum[1-3]

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/Path/BlackScholesUnitTest.cu}}]
//
\end{lstlisting}

\subsection{\texttt{main.cu}}
\lipsum[1-3]

\begin{lstlisting}[language=C++, caption={\texttt{main.cu}}]
#include <iostream>
#include <ctime>		// time(NULL)
#include <climits>		// UINT_MAX

#include "libraries/InputStructures/InputGPUData/Input_gpu_data.cuh"
#include "libraries/InputStructures/InputMarketData/Input_market_data.cuh"
#include "libraries/InputStructures/InputMCData/Input_MC_data.cuh"
#include "libraries/InputStructures/InputOptionData/Input_option_data.cuh"
#include "libraries/CoreLibraries/DataStreamManager/Data_stream_manager.cuh"
#include "libraries/CoreLibraries/SupportFunctions/Support_functions.cuh"

using namespace std;

int main(){
	
	// Read & print input data from file
	Data_stream_manager streamManager("input.dat");
	
	Input_gpu_data inputGPU;
	Input_option_data inputOption;
	Input_market_data inputMarket;
	Input_MC_data inputMC;
	streamManager.ReadInputData(inputGPU, inputOption, inputMarket, inputMC);
	streamManager.PrintInputData(inputGPU, inputOption, inputMarket, inputMC);

	// Seed for random number generation
	// Fix it to a value between 129 and UINT_MAX-totalNumberOfThreads or let time(NULL) do its magic
	unsigned int seed;	
	do
		seed = time(NULL);
	while(seed < 129 || seed > UINT_MAX - inputGPU.GetTotalNumberOfThreads());	
	
	////////////// HOST-SIDE ALGORITHM //////////////
	if(inputMC.CpuOrGpu == 'c' || inputMC.CpuOrGpu == 'b')
		CPUOptionPricingMonteCarloAlgorithm(streamManager, inputGPU, inputOption, inputMarket, inputMC, seed);


	////////////// DEVICE-SIDE ALGORITHM //////////////
	if(inputMC.CpuOrGpu == 'g' || inputMC.CpuOrGpu == 'b')
		GPUOptionPricingMonteCarloAlgorithm(streamManager, inputGPU, inputOption, inputMarket, inputMC, seed);

	return 0;
}
\end{lstlisting}

\begin{lstlisting}[language=bash, caption={\texttt{input.dat}}]
####### INPUT DATA FOR OPTION PRICING #######
### Comments beginning with # are ignored ###
#
#
#
## GPU DATA
# Number of GPU blocks
50
## MARKET DATA
# Initial underlying price at t = 0 [USD]
100
# Market volatility
0.25
# Risk-free interest rate [percentage, i.e. 0.1 = 10%]
0.01
## OPTION DATA
## NOTE: for flexibility, all option data are read even if they will not be used
## (e.g. because forward contract does not have a strike price)
## Please don't leave any line empty, use arbitrary values instead
#
## BASE/FORWARD CONTRACT DATA
# Time to maturity [years]
1
# Number of intervals in which TTM is divided
400
# Option type
# f = forward contract
# c = plain vanilla call option
# p = plain vanilla put option
# e = performance corridor option
c
## PLAIN VANILLA OPTION DATA
# Option strike price [USD]
100
## PERFORMANCE CORRIDOR OPTION DATA
# B
1
# K [percentage, i.e. 0.1 = 10%]
0.3
# N [EUR]
1
## MONTE CARLO DATA
# Number of simulations
100000000
# CPU/GPU comparison
# c = cpu-only
# g = gpu-only
# b = both
g
# Gaussian or bimodal (1/-1) random variable
# g = gaussian
# b = bimodal
g
#
#
#############################################
#############################################
\end{lstlisting}