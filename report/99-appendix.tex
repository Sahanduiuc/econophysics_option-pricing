\appendix
\chapter{Listato commentato del codice} \label{app:allcode}

\section{Strutture di \textit{input}}
Il codice si sviluppa secondo uno schema ramificato di cartelle dai nomi autoesplicativi, così da rendere il più semplice possibile tanto la lettura quanto la modifica delle singole strutture secondarie. La prima macrocategoria in ordine logico è quella raggruppante le classi dei dati di \textit{input} per la simulazione. Tali dati sono stati accorpati nelle seguenti quattro famiglie di \codeword{struct} in base al tipo di informazione di cui sono portatori.

\subsection{\texttt{Input\_gpu\_data}}
La prima struttura di cui ci occupiamo è quella relativa alle informazioni per l'esecuzione del codice su scheda grafica.

Tale struttura contiene un unico dato membro in cui viene immagazzinato il numero di blocchi, mentre una direttiva a preprocessore fissa quello di \textit{thread} per blocco a $512$ così da permettere il calcolo del numero totale di \textit{thread} richiesti.

\begin{lstlisting}[language=C++, caption={\texttt{libraries/InputStructures/InputGPUData/Input\_gpu\_data.cuh}}]
#ifndef __Input_gpu_data_h__
#define __Input_gpu_data_h__

#define NUMBER_OF_THREADS_PER_BLOCK 512

struct Input_gpu_data{
	unsigned int NumberOfBlocks;

	__device__ __host__ unsigned int GetNumberOfThreadsPerBlock() const;
	__device__ __host__ unsigned int GetTotalNumberOfThreads() const;

};
#endif
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={\texttt{libraries/InputStructures/InputGPUData/Input\_gpu\_data.cu}}]
#include "Input_gpu_data.cuh"

using namespace std;

__device__ __host__ unsigned int Input_gpu_data::GetNumberOfThreadsPerBlock() const{
	return NUMBER_OF_THREADS_PER_BLOCK;
}

__device__ __host__ unsigned int Input_gpu_data::GetTotalNumberOfThreads() const{
	return this->NumberOfBlocks * NUMBER_OF_THREADS_PER_BLOCK;
}
\end{lstlisting}

\subsection{\texttt{Input\_market\_data}}
\codeword{Input_market_data} è la \codeword{struct} relativa ai dati di mercato: la sua volatilità, il tasso di interesse privo di rischio e il prezzo del bene sottostante al tempo iniziale $t=0$.

\begin{lstlisting}[language=C++, caption={\texttt{libraries/InputStructures/InputMarketData/Input\_market\_data.cuh}}]
#ifndef __Input_Market_data_h__
#define __Input_Market_data_h__

struct Input_market_data{
	
	double InitialPrice;				// Initial price of the asset
	double Volatility;					// Volatility
	double RiskFreeRate;				// Risk-free interest

};
#endif
\end{lstlisting}

\subsection{\texttt{Input\_option\_data}}
Avendo preso in considerazione opzioni europee di tipo \textit{plain vanilla call} e \textit{put}, contratto \textit{forward} e l'opzione esotica \textit{performance corridor}, la struttura \codeword{Input_option_data} in cui sono inseriti i dati dell'opzione è costruita su due livelli così da garantire la massima generalità.

Le informazioni primarie sono quelle relative al tipo di prodotto derivato considerato (si veda la legenda nei commenti) o comuni a tutte le tipologie che abbiamo preso in considerazione: numero di date di rilevazione e data di maturità. Sono poi presenti dati propri della singola tipologia di opzione: il prezzo di esercizio per le \textit{plain vanilla} e le costanti per il calcolo del \textit{pay-off} nelle \textit{performance corridor}.

\begin{lstlisting}[language=C++, caption={\texttt{libraries/InputStructures/InputOptionData/Input\_option\_data.cuh}}]
#ifndef __Input_option_data_h__
#define __Input_option_data_h__

struct Input_option_data{
	
	// Common to all option types
	char OptionType;		// f = forward contract
							// c = plain vanilla call option
							// p = plain vanilla put option
							// e = performance corridor option
	unsigned int NumberOfIntervals;
	double TimeToMaturity;

	__device__ __host__ double GetDeltaTime() const;
	
	// Specific to plain vanilla options
	double StrikePrice;
		
	// Specific to performance corridor options
	double B;
	double K;
	double N;

};

#endif
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={\texttt{libraries/InputStructures/InputOptionData/Input\_option\_data.cu}}]
#include "Input_option_data.cuh"

using namespace std;

__device__ __host__ double Input_option_data::GetDeltaTime() const{
	return static_cast<double>(static_cast<double>(this->TimeToMaturity) / static_cast<unsigned int>(this->NumberOfIntervals));	
}
\end{lstlisting}

\subsection{\texttt{Input\_MC\_data}}
L'ultima struttura di \textit{input} implementata, \codeword{Input_MC_data}, gestisce le informazioni relative alla simulazione Monte Carlo in sé: oltre a fissare il numero totale di simulazioni, essa contiene istruzioni per l'algoritmo circa l'esecuzione su CPU, GPU o entrambe e sull'impiego di variabili aleatorie gaussiane o bimodali nel processo lognormale.

\begin{lstlisting}[language=C++, caption={\texttt{libraries/InputStructures/InputMCData/Input\_MC\_data.cuh}}]
#ifndef __Input_MC_data_h__
#define __Input_MC_data_h__

#include "../InputGPUData/Input_gpu_data.cuh"

struct Input_MC_data{

	unsigned int NumberOfMCSimulations;
	char CpuOrGpu;	// g = gpu algorithm only
					// c = cpu algorithm only
					// b = both algorithms are used
	char GaussianOrBimodal;	// g = gaussian variables are used
							// b = bimodal (1/-1) variables are used
	
	__device__ __host__ unsigned int GetNumberOfSimulationsPerThread(const Input_gpu_data&) const;

};

#endif
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={\texttt{libraries/InputStructures/InputMCData/Input\_MC\_data.cu}}]
#include <cmath>	// ceil

#include "Input_MC_data.cuh"
#include "../InputGPUData/Input_gpu_data.cuh"

using namespace std;

__device__ __host__ unsigned int Input_MC_data::GetNumberOfSimulationsPerThread(const Input_gpu_data& inputGPU) const{
	return ceil(static_cast<double>(this->NumberOfMCSimulations) / inputGPU.GetTotalNumberOfThreads());
}
\end{lstlisting}

\section{Strutture di \textit{output}}
Come per le strutture di \textit{input}, anche nel caso degli \textit{output} abbiamo implementato un contenitore in cui raggruppare i risultati delle simulazioni. Il prodotto di ogni esecuzione non restituisce dati suddivisibili in categorie come per gli \textit{input}; la struttura che ingloba gli \textit{output} è quindi unica.

\subsection{\texttt{Output\_MC\_data}}
In \codeword{Output_MC_data} vengono immagazzinati i dati relativi ai \textit{pay-off} calcolati tramite il processo lognormale esatto e di Eulero, con annessa indicazione dello strumento di calcolo che ha effettuato la simulazione (CPU o GPU). Sono inoltre inseriti i valori degli errori su entrambi i risultati e il tempo di calcolo del processo. Attraverso il metodo \codeword{GetEulerToExactDiscrepancy()} è possibile ottenere la discrepanza in unità di sigma tra i due risultati ottenuti.

\begin{lstlisting}[language=C++, caption={\texttt{libraries/OutputStructures/OutputMCData/Output\_MC\_data.cuh}}]
#ifndef __Output_MC_data_h__
#define __Output_MC_data_h__

struct Output_MC_data{
	
	char HostOrDevice;
	double EstimatedPriceMCEuler;
	double ErrorMCEuler;
	double EstimatedPriceMCExact;
	double ErrorMCExact;
	double Tick;			// Calculation time [ms]
	unsigned int NegativePriceCounter;
	
	__device__ __host__ double GetRelativeErrorEuler() const;
	__device__ __host__ double GetRelativeErrorExact() const;
	__device__ __host__ double GetEulerToExactDiscrepancy() const;

};

#endif
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={\texttt{libraries/OutputStructures/OutputMCData/Output\_MC\_data.cu}}]
#include <cmath>	// fabs, sqrt, pow

#include "Output_MC_data.cuh"

__device__ __host__ double Output_MC_data::GetRelativeErrorEuler() const{
	return this->ErrorMCEuler / this->EstimatedPriceMCEuler;
}

__device__ __host__ double Output_MC_data::GetRelativeErrorExact() const{
	return this->ErrorMCExact / this->EstimatedPriceMCExact;
}

__device__ __host__ double Output_MC_data::GetEulerToExactDiscrepancy() const{
	return fabs((this->EstimatedPriceMCEuler - this->EstimatedPriceMCExact)/sqrt(pow(this->ErrorMCEuler,2)+pow(ErrorMCExact,2)));
}
\end{lstlisting}

\section{Librerie principali}
Con la dicitura <<librerie principali>> indichiamo quell'insieme di librerie che costituisce il cuore dell'intero algoritmo. Ogni cartella si occupa di una precisa fase implementativa, di cui daremo una breve descrizione nei sottoparagrafi successivi.

\subsection{\texttt{RNG}, \texttt{RNG\_Tausworthe}, \texttt{RNG\_CombinedGenerator}}
L'algoritmo Monte Carlo, nella sua definizione più generale, è un metodo computazionale che produce stime numeriche a partire da campionamenti casuali. Da qui la necessità di potersi servire di un generatore di numeri pseudocasuali con periodo sufficientemente ampio.

L'approccio da noi prescelto sfrutta l'ereditarietà tipica del linguaggio C++ attraverso la creazione di una classe astratta \codeword{RNG} da cui si diramano le classi figlie dei generatori specifici. Comuni a tutti i generatori sono i seguenti metodi virtuali:
\begin{itemize}
    \item \codeword{ResetSeed()}, metodo che ripristina i valori dei \textit{seed} a una situazione predefinita;
    \item \codeword{GetUnsignedInt()}, metodo che genera una variabile pseudocasuale intera uniformemente distribuita tra $0$ e \codeword{UINT_MAX}, costante dipendente dal sistema in uso che indica il massimo valore assegnabile a un oggetto di tipo \codeword{unsigned int};
    \item \codeword{GetUniform()}, metodo che genera una variabile pseudocasuale reale uniformemente distribuita nell'intervallo $[0,1]$;
    \item \codeword{GetGauss()}, metodo che genera una variabile pseudocasuale reale secondo una distribuzione normale di media nulla e varianza unitaria;
    \item \codeword{GetBimodal()}, metodo che genera una variabile pseudocasuale dicotomica che assume i soli valori $\pm1$ con uguale probabilità;
    \item \codeword{SetInternalState(RNG*)}: metodo per inizializzare il generatore con \textit{seed} prodotti da un secondo generatore ausiliario.
\end{itemize}

Ogni generatore fornisce la propria implementazione dei metodi virtuali puri della classe madre, un costruttore di \textit{default} e uno che prende in ingresso il necessario numero di \textit{seed}, ossia uno per il generatore \codeword{RNG_Tausworthe} e quattro per il generatore combinato \codeword{RNG_CombinedGenerator}. Quest'ultimo è ottenuto a partire da tre generatori Tausworthe (periodi $2^{31}-1$, $2^{30}-1$ e $2^{28}-1$) e da un generatore lineare congruenziale (periodo $2^{32}$), che non ha una propria identità di classe ma è implementato come metodo interno a \codeword{RNG_CombinedGenerator}; il periodo complessivo è dato dal minimo comune multiplo dei periodi dei singoli generatori, ovvero $\approx 2^{121}$. Per approfondimenti inerenti l'uso dei generatori nel corpo dell'algoritmo si faccia riferimento alla Sezione \ref{sec:correlation_check}.

Legata all'argomento di generatori pseudocasuali è la libreria \codeword{CorrelationToolbox}, dove sono raccolte funzioni ausiliarie utili per i test di autocorrelazione descritti in Sezione \ref{sec:correlation_check}; a differenza delle altre librerie elencate, questa non gioca alcun ruolo nell'eseguibile principale ed è invece utilizzata solo in \verb|CorrelationTests.cu|. Essa è costituita da:
\begin{itemize}
    \item un metodo \codeword{RandomNumberGeneration(...)} per la generazione di numeri pseudocasuali su sola CPU secondo una distribuzione uniforme in $[0,1]$ e una distribuzione normale di media nulla e varianza unitaria;
    \item una serie di metodi per il calcolo di media, varianza, curtosi e autocorrelazione di un singolo flusso di numeri, caratterizzati dal suffisso \codeword{SingleStream};
    \item una serie di metodi, caratterizzati dal suffisso \codeword{MultipleStreams}, che implementano i precedenti per un vettore di flussi, quale per esempio quello prodotto in uscita dalla funzione \codeword{RandomNumberGeneration(...)}.
\end{itemize}

In ragione della mole di dati generata da alcuni dei metodi, in particolare quelli legati all'autocorrelazione, laddove opportuno abbiamo definito una variabile booleana \codeword{verbose} in ingresso, sulla base della quale viene deciso se stampare o meno a schermo i risultati.

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/RandomGenerator/RNG.cuh}}]
#ifndef _RNG__H
#define _RNG__H

class RNG{
	
	public:
		// Virtual functions from base class
		__device__ __host__ virtual void ResetSeed() = 0;
		__device__ __host__ virtual unsigned int GetUnsignedInt() = 0;
		__device__ __host__ virtual double GetUniform() = 0;
		__device__ __host__ virtual double GetGauss() = 0;
		__device__ __host__ virtual double GetBimodal() = 0;
		__device__ __host__ virtual void SetInternalState(RNG*) = 0;
		
};

class RNG_Tausworthe: public RNG{
	
	private:
		
		unsigned int _Seed;
		
		__device__ __host__ unsigned int TausStep();
	
	public:
	
		// Constructors and destructor
		__device__ __host__ RNG_Tausworthe();
		__device__ __host__ RNG_Tausworthe(const unsigned int);
		__device__ __host__ ~RNG_Tausworthe() = default;	
		
		// Virtual functions from base class
		__device__ __host__ void ResetSeed();
		__device__ __host__ unsigned int GetUnsignedInt();
		__device__ __host__ double GetUniform();
		__device__ __host__ double GetGauss();
		__device__ __host__ double GetBimodal();
		__device__ __host__ void SetInternalState(RNG*);
		
};

class RNG_CombinedGenerator: public RNG{
	
	public:
	
		// Constructors and destructor
		__device__ __host__ RNG_CombinedGenerator();
		__device__ __host__ RNG_CombinedGenerator(const unsigned int, const unsigned int, const unsigned int, const unsigned int);
		__device__ __host__ ~RNG_CombinedGenerator() = default;
		
		// Virtual functions from base class
		__device__ __host__ void ResetSeed();
		__device__ __host__ unsigned int GetUnsignedInt();
		__device__ __host__ double GetUniform();
		__device__ __host__ double GetGauss();
		__device__ __host__ double GetBimodal();

		// Public internal state set (unsigned ints between 129 and UINT_MAX)
		__device__ __host__ void SetInternalState(RNG*);
	
	private:
		// Seeds: 3 taus + 1 LCGS
		unsigned int _SeedLCGS;
		unsigned int _SeedTaus1;
		unsigned int _SeedTaus2;
		unsigned int _SeedTaus3;
		
		// Single steps (callable from device and host, no need to diversify)
		__device__ __host__ unsigned int LCGStep();
		__device__ __host__ unsigned int TausStep1();
		__device__ __host__ unsigned int TausStep2();
		__device__ __host__ unsigned int TausStep3();
		__device__ __host__ unsigned int HybridTausGenerator();
};

#endif
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/RandomGenerator/RNG.cu}}]
#include <cmath>		// log, cos, sin, M_PI

#include "RNG.cuh"

using namespace std;

//
//	TAUSWORTHE GENERATOR
//

// Constructor and destructor
__device__ __host__ RNG_Tausworthe::RNG_Tausworthe(){
	_Seed = 129;
}
__device__ __host__ RNG_Tausworthe::RNG_Tausworthe(const unsigned int seed){
	_Seed = seed;
}

// Private functions
__device__ __host__ unsigned int RNG_Tausworthe::TausStep(){
	int S1 = 23, S2 = 5, S3 = 29;
	unsigned int M = 4294967240UL;
	unsigned int z = this->_Seed;
	
	unsigned b = (((z << S1) ^ z) >> S2);

	this->_Seed = (((z & M) << S3) ^ b);
	return _Seed;		
}

// Virtual functions from base class
__device__ __host__ void RNG_Tausworthe::ResetSeed(){
	_Seed = 129;	
}

__device__ __host__ unsigned int RNG_Tausworthe::GetUnsignedInt(){
	return this->TausStep();
}

__device__ __host__ double RNG_Tausworthe::GetUniform(){
	return 2.3283064365387e-10 * this->GetUnsignedInt();	
}

__device__ __host__ double RNG_Tausworthe::GetGauss(){
	double u = this->GetUniform();
	double v = this->GetUniform();

	return sqrt(-2.*log(u)) * cos(2.*M_PI*v);	
}

__device__ __host__ double RNG_Tausworthe::GetBimodal(){
	double gaussian;

	do{
		gaussian = this->GetGauss();
		
		if(gaussian > 0.)
			return 1.;
		else if(gaussian < 0.)
			return -1.;
	}while(gaussian == 0.);
	
	return -1000.;	// If this ever gets called, we're in trouble
}

__device__ __host__ void RNG_Tausworthe::SetInternalState(RNG* supportGenerator){
	unsigned int seed;
	
	do
		seed = supportGenerator->GetUnsignedInt();
	while(seed < 129);
	
	this->_Seed = seed;
}

//
//	COMBINED GENERATOR
//

__device__ __host__ RNG_CombinedGenerator::RNG_CombinedGenerator(const unsigned int seed1, const unsigned int seed2, const unsigned int seed3, const unsigned int seed4){
	this->_SeedLCGS = seed1;
	this->_SeedTaus1 = seed2;
	this->_SeedTaus2 = seed3;
	this->_SeedTaus3 = seed4;
}

__device__ __host__ RNG_CombinedGenerator::RNG_CombinedGenerator(){
	this->_SeedLCGS = 0;
	this->_SeedTaus1 = 129;
	this->_SeedTaus2 = 130;
	this->_SeedTaus3 = 131;
}

__device__ __host__ unsigned int RNG_CombinedGenerator::TausStep1(){
	int S1 = 13, S2 = 19, S3 = 12;
	unsigned int M = 4294967294UL;
	unsigned int z = this->_SeedTaus1;
	
	unsigned b = (((z << S1) ^ z) >> S2);
	
	this->_SeedTaus1 = (((z & M) << S3) ^ b);
	return _SeedTaus1;
}

__device__ __host__ unsigned int RNG_CombinedGenerator::TausStep2(){
	int S1 = 2, S2 = 25, S3 = 4;
	unsigned int M = 4294967288UL;
	unsigned int z = this->_SeedTaus2;
	
	unsigned b = (((z << S1) ^ z) >> S2);

	this->_SeedTaus2 = (((z & M) << S3) ^ b);
	return _SeedTaus2;
}
__device__ __host__ unsigned int RNG_CombinedGenerator::TausStep3(){
	int S1 = 3, S2 = 11, S3 = 17;
	unsigned int M = 4294967280UL;
	unsigned int z = this->_SeedTaus3;
	
	unsigned b = (((z << S1) ^ z) >> S2);

	this->_SeedTaus3 = (((z & M) << S3) ^ b);
	return _SeedTaus3;
}

__device__ __host__ unsigned int RNG_CombinedGenerator::LCGStep(){
	unsigned int z = this->_SeedLCGS;
	unsigned int A = 1664525;
	unsigned int C = 1013904223UL;
	this->_SeedLCGS = (A*z + C);
	return _SeedLCGS;
}

__device__ __host__ unsigned int RNG_CombinedGenerator::HybridTausGenerator(){
	return (
		this->TausStep1() ^
		this->TausStep2() ^
		this->TausStep3() ^
		this->LCGStep()
	);
}

__device__ __host__ void RNG_CombinedGenerator::ResetSeed(){
	this->_SeedLCGS = 0;
	this->_SeedTaus1 = 129;
	this->_SeedTaus2 = 130;
	this->_SeedTaus3 = 131;
}

__device__ __host__ unsigned int RNG_CombinedGenerator::GetUnsignedInt(){
	return this->HybridTausGenerator();
}

__device__ __host__ double RNG_CombinedGenerator::GetUniform(){
	return 2.3283064365387e-10 * this->GetUnsignedInt();
}

__device__ __host__ double RNG_CombinedGenerator::GetGauss(){
	double u = this->GetUniform();
	double v = this->GetUniform();

	return sqrt(-2.*log(u)) * cos(2.*M_PI*v);
}

__device__ __host__ double RNG_CombinedGenerator::GetBimodal(){
	double gaussian;

	do{
		gaussian = this->GetGauss();
		
		if(gaussian > 0.)
			return 1.;
		else if(gaussian < 0.)
			return -1.;
	}while(gaussian == 0.);

	return -1000.;	// If this ever gets called, we're in trouble
}

__device__ __host__ void RNG_CombinedGenerator::SetInternalState(RNG* supportGenerator){
	this->_SeedLCGS = supportGenerator->GetUnsignedInt();
	
	unsigned int seedTaus1, seedTaus2, seedTaus3;
	
	do
		seedTaus1 = supportGenerator->GetUnsignedInt();
	while(seedTaus1 < 129);
	
	do
		seedTaus2 = supportGenerator->GetUnsignedInt();
	while(seedTaus2 < 129);
	
	do
		seedTaus3 = supportGenerator->GetUnsignedInt();
	while(seedTaus3 < 129);
	
	this->_SeedTaus1 = seedTaus1;
	this->_SeedTaus2 = seedTaus2;
	this->_SeedTaus3 = seedTaus3;
}
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/RandomGenerator/CorrelationToolbox.cuh}}]
#ifndef _CORRELATION__TOOLBOX_CUH
#define _CORRELATION__TOOLBOX_CUH

#include "RNG.cuh"

// Random number generator
__host__ void RandomNumberGeneration(unsigned int numberOfBlocks, unsigned int numberOfThreadsPerBlock, double **uniformNumbers, double **gaussianNumbers, unsigned int totalNumbersToGenerate, unsigned int numbersToGeneratePerThread, unsigned int seed);

// Single stream toolbox. A true verbose variable will print the output for further testing
__host__ double GetAverage_SingleStream(double *inputStream, unsigned int streamSize);
__host__ double GetVariance_SingleStream(double *inputStream, double streamAverage, unsigned int streamSize);
__host__ double GetKurtosis_SingleStream(double *inputStream, double streamAverage, double streamVariance, unsigned int streamSize);
__host__ double GetAutocorrelationK_SingleStream(double *inputStream, unsigned int autocorrelationOffset, unsigned int streamSize);
	// Accepts two vectors: one is streamSize sized, the other is streamSize-2
__host__ void EvaluateCompleteAutocorrelation_SingleStream(double *inputStream, double *outputCorrelations, unsigned int streamSize, bool verbose);


// Many-streams toolbox. A true verbose variable will print the output for further testing
__host__ void EvaluateAverage_MultipleStreams(double **inputStreams, double *outputStreamAverages, unsigned int totalNumberOfThreads, unsigned int numbersToGeneratePerThread, bool verbose);
__host__ void EvaluateVariance_MultipleStreams(double **inputStreams, double *inputStreamAverages, double *outputStreamVariances, unsigned int totalNumberOfThreads, unsigned int numbersToGeneratePerThread, bool verbose);
__host__ void EvaluateKurtosis_MultipleStreams(double **inputStreams, double *inputStreamAverages, double *inputStreamVariances, double *outputStreamKurtosises, unsigned int totalNumberOfThreads, unsigned int numbersToGeneratePerThread, bool verbose);
	// Accepts two matrixes with totalNumberOfThreads as first index and numbersToGeneratePerThread or numbersToGeneratePerThread-2 as second index respectively
__host__ void EvaluateCompleteAutocorrelation_MultipleStreams(double **inputStreams, double **outputStreamCorrelations, unsigned int totalNumberOfThreads, unsigned int numbersToGeneratePerThread, bool verbose);

#endif
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/RandomGenerator/CorrelationToolbox.cu}}]
#include <iostream>

#include "CorrelationToolbox.cuh"

using namespace std;

// Random number generator

__host__ void RandomNumberGeneration(unsigned int numberOfBlocks, unsigned int numberOfThreadsPerBlock, double **uniformNumbers, double **gaussianNumbers, unsigned int totalNumbersToGenerate, unsigned int numbersToGeneratePerThread, unsigned int seed){

	for(unsigned int threadNumber=0; threadNumber<numberOfBlocks*numberOfThreadsPerBlock; ++threadNumber){
		RNG *supportGenerator = new RNG_Tausworthe(seed+threadNumber);
		RNG *mainGenerator = new RNG_CombinedGenerator;
		mainGenerator->SetInternalState(supportGenerator);

		for(unsigned int RNGNumber=0; RNGNumber<numbersToGeneratePerThread; ++RNGNumber){		
			if(numbersToGeneratePerThread*threadNumber+RNGNumber < totalNumbersToGenerate){
				uniformNumbers[threadNumber][RNGNumber] = mainGenerator->GetUniform();
				gaussianNumbers[threadNumber][RNGNumber] = mainGenerator->GetGauss();
			}
		}
	}
}

// Single stream toolbox
__host__ double GetAverage_SingleStream(double *inputStream, unsigned int streamSize){
	double streamSum = 0.;
	unsigned int streamCounter = 0;
	
	for(unsigned int RNGIndex=0; RNGIndex<streamSize; ++RNGIndex){
		streamSum += inputStream[RNGIndex];
		++streamCounter;
	}
	
	return streamSum / streamCounter;
}

__host__ double GetVariance_SingleStream(double *inputStream, double streamAverage, unsigned int streamSize){
	double streamSquaredDiscrepancyFromAverage = 0.;
	unsigned int streamCounter = 0;

	for(unsigned int RNGIndex=0; RNGIndex<streamSize; ++RNGIndex){
		streamSquaredDiscrepancyFromAverage += pow(inputStream[RNGIndex] - streamAverage,2);
		++streamCounter;
	}
	
	return streamSquaredDiscrepancyFromAverage / streamCounter;	
}

__host__ double GetKurtosis_SingleStream(double *inputStream, double streamAverage, double streamVariance, unsigned int streamSize){
	double streamQuarticDiscrepancyFromAverage = 0.;
	unsigned int streamCounter = 0;
	
	for(unsigned int RNGIndex=0; RNGIndex<streamSize; ++RNGIndex){
		streamQuarticDiscrepancyFromAverage += pow(inputStream[RNGIndex] - streamAverage,4);
		++streamCounter;
	}
	
	return streamQuarticDiscrepancyFromAverage / (streamCounter * pow(streamVariance,4));

}

__host__ double GetAutocorrelationK_SingleStream(double *inputStream, unsigned int autocorrelationOffset, unsigned int streamSize){
	double streamCorrelationSum = 0.;
	unsigned int streamCounter = 0;

	for(unsigned int RNGIndex=0; RNGIndex<streamSize-autocorrelationOffset; ++RNGIndex){
		streamCorrelationSum += inputStream[RNGIndex] * inputStream[RNGIndex+autocorrelationOffset];
		++streamCounter;
	}
	
	return streamCorrelationSum / streamCounter;
}

__host__ void EvaluateCompleteAutocorrelation_SingleStream(double *inputStream, double *outputCorrelations, unsigned int streamSize, bool verbose){
	for(unsigned int autocorrelationOffset=1; autocorrelationOffset<streamSize-1; ++autocorrelationOffset){
		outputCorrelations[autocorrelationOffset-1] = GetAutocorrelationK_SingleStream(inputStream, autocorrelationOffset, streamSize);
		
		if(verbose)
			if(autocorrelationOffset % 20 == 0)
				cout << "<xi*xi+" << autocorrelationOffset << ">:\t" << outputCorrelations[autocorrelationOffset-1] << endl;
	}
}


// Toolbox to test correlation of a stream of totalNumberOfThreads, each generating numbersToGeneratePerThread random numbers. A positive verbose variable will, well, print the output for further testing

__host__ void EvaluateAverage_MultipleStreams(double **inputStreams, double *outputStreamAverages, unsigned int totalNumberOfThreads, unsigned int numbersToGeneratePerThread, bool verbose){
	for(unsigned int threadIndex=0; threadIndex<totalNumberOfThreads; ++threadIndex){
		outputStreamAverages[threadIndex] = GetAverage_SingleStream(inputStreams[threadIndex],numbersToGeneratePerThread);	
		if(verbose)
			cout << "<xi>@thread" << threadIndex << ":\t" << outputStreamAverages[threadIndex] << endl;
	}
}

__host__ void EvaluateVariance_MultipleStreams(double **inputStreams, double *inputStreamAverages, double *outputStreamVariances, unsigned int totalNumberOfThreads, unsigned int numbersToGeneratePerThread, bool verbose){
	for(unsigned int threadIndex=0; threadIndex<totalNumberOfThreads; ++threadIndex){
		outputStreamVariances[threadIndex] = GetVariance_SingleStream(inputStreams[threadIndex], inputStreamAverages[threadIndex], numbersToGeneratePerThread);
		if(verbose)
			cout << "var(xi)@thread" << threadIndex << ":\t" << outputStreamVariances[threadIndex] << endl;
	}
}

__host__ void EvaluateKurtosis_MultipleStreams(double **inputStreams, double *inputStreamAverages, double *inputStreamVariances, double *outputStreamKurtosises, unsigned int totalNumberOfThreads, unsigned int numbersToGeneratePerThread, bool verbose){
	for(unsigned int threadIndex=0; threadIndex<totalNumberOfThreads; ++threadIndex){
		outputStreamKurtosises[threadIndex] = GetKurtosis_SingleStream(inputStreams[threadIndex], inputStreamAverages[threadIndex], inputStreamVariances[threadIndex], numbersToGeneratePerThread);
		if(verbose)
			cout << "kurt(xi)@thread" << threadIndex << ":\t" << outputStreamKurtosises[threadIndex] << endl;
	}
}

__host__ void EvaluateCompleteAutocorrelation_MultipleStreams(double **inputStreams, double **outputStreamCorrelations, unsigned int totalNumberOfThreads, unsigned int numbersToGeneratePerThread, bool verbose){
	for(unsigned int threadIndex=0; threadIndex<totalNumberOfThreads; ++threadIndex){
				
		if(verbose)
			cout << "@thread" << threadIndex << ":" << endl;

		EvaluateCompleteAutocorrelation_SingleStream(inputStreams[threadIndex], outputStreamCorrelations[threadIndex], numbersToGeneratePerThread, verbose);
	}
}
\end{lstlisting}

\subsection{\texttt{Path}}
Sulla classe \codeword{Path} si innesta il processo iterativo che permette il calcolo del prezzo del sottostante alla data di maturità attraverso la ricorsione dei metodi \codeword{EulerLogNormalStep (double)} e \codeword{ExactLogNormalStep(double)}.

Oltre a una variabile di appoggio \codeword{_SpotPrice} per la temporanea memorizzazione del prezzo al passo $i$-esimo, la classe è dotata di dati membri privati dichiarati per composizione tramite cognizione, ovvero istanziando puntatori alle aree di memoria in questione evitando di creare copie fisiche degli oggetti; ciò permette di conservare informazioni relative a mercato e opzione considerata senza occupare ulteriore spazio in memoria, rendendo inoltre la classe più versatile rispetto a modifiche dei dati anagrafici. Un dato membro booleano \codeword{_NegativePrice} tiene inoltre traccia di possibili rendimenti negativi restituiti dal processo lognormale di Eulero (fare riferimento alla Sezione \ref{sec:limits}). La classe è infine dotata di un metodo per il calcolo del \textit{pay-off} attualizzato.

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/Path/Path.cuh}}]
#ifndef __Path_h__
#define __Path_h__

#include "../../InputStructures/InputMarketData/Input_market_data.cuh"
#include "../../InputStructures/InputOptionData/Input_option_data.cuh"

class Path{

	private:
		
		double _SpotPrice;		// The step (spotprice) required to generate the next one

		// Market data
		const double* _RiskFreeRate;
		const double* _Volatility;
		const double* _InitialPrice;

		// Base European option/contract data
		const char* _OptionType;
		const unsigned int* _NumberOfIntervals;
		const double* _TimeToMaturity;
		double _DeltaTime;
		
		// Plain vanilla option data
		const double* _StrikePrice;
		
		// Performance corridor data
		const double* _B;
		const double* _K;
		const double* _N;
		unsigned int _PerformanceCorridorBarrierCounter;
		
		// Boolean keeping track of negative prices in the Euler formula
		bool _NegativePrice;
		
		__device__ __host__ void CheckPerformanceCorridorCondition(double currentSpotPrice, double nextSpotPrice);
		
	public:

		__device__ __host__ Path();
		__device__ __host__ Path(const Input_market_data& market, const Input_option_data& option);
		__device__ __host__ ~Path() = default;

		__device__ __host__ void ResetToInitialState(const Input_market_data& market, const Input_option_data& option);
		__device__ __host__ void ResetToInitialState(const Path&);

		__device__ __host__ void EulerLogNormalStep(double gaussianRandomVariable);
		__device__ __host__ void ExactLogNormalStep(double gaussianRandomVariable);
		
		__device__ __host__ double GetSpotPrice() const;
		__device__ __host__ unsigned int GetPerformanceCorridorBarrierCounter() const;
		
		// Payoff evaluation
		__device__ __host__ double GetActualizedPayoff() const;
		
		// Check if a negative price happened in this run
		__device__ __host__ bool GetNegativePrice() const;

};

#endif
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/Path/Path.cu}}]
#include <cmath>	// sqrt, pow, fmax, log, exp, fabs

#include "Path.cuh"
#include "../../InputStructures/InputMarketData/Input_market_data.cuh"
#include "../../InputStructures/InputOptionData/Input_option_data.cuh"

using namespace std;

// Constructors
__device__ __host__ Path::Path(){
	this->_OptionType = NULL;
	this->_SpotPrice = 0.;
	this->_RiskFreeRate = NULL;
	this->_Volatility = NULL;
	this->_InitialPrice = NULL;
	this->_TimeToMaturity = NULL;
	this->_NumberOfIntervals = NULL;
	this->_DeltaTime = 0.;
	this->_StrikePrice = NULL;
	this->_B = NULL;
	this->_N = NULL;
	this->_K = NULL;
	this->_PerformanceCorridorBarrierCounter = 0;
	this->_NegativePrice = false;
}

__device__ __host__ Path::Path(const Input_market_data& market, const Input_option_data& option){
	this->_OptionType = &(option.OptionType);
	this->_SpotPrice = market.InitialPrice;
	this->_RiskFreeRate = &(market.RiskFreeRate);
	this->_Volatility = &(market.Volatility);
	this->_InitialPrice = &(market.InitialPrice);
	this->_TimeToMaturity = &(option.TimeToMaturity);
	this->_NumberOfIntervals = &(option.NumberOfIntervals);
	this->_DeltaTime = option.GetDeltaTime();
	this->_StrikePrice = &(option.StrikePrice);
	this->_B = &(option.B);
	this->_N = &(option.N);
	this->_K = &(option.K);
	this->_PerformanceCorridorBarrierCounter = 0;
	this->_NegativePrice = false;
}

// Public set methods
__device__ __host__ void Path::ResetToInitialState(const Input_market_data& market, const Input_option_data& option){
	this->_OptionType = &(option.OptionType);
	this->_SpotPrice = market.InitialPrice;
	this->_RiskFreeRate = &(market.RiskFreeRate);
	this->_Volatility = &(market.Volatility);
	this->_InitialPrice = &(market.InitialPrice);
	this->_TimeToMaturity = &(option.TimeToMaturity);
	this->_NumberOfIntervals = &(option.NumberOfIntervals);
	this->_DeltaTime = option.GetDeltaTime();
	this->_StrikePrice = &(option.StrikePrice);
	this->_B = &(option.B);
	this->_N = &(option.N);
	this->_K = &(option.K);
	this->_PerformanceCorridorBarrierCounter = 0;
	this->_NegativePrice = false;
}

__device__ __host__ void Path::ResetToInitialState(const Path& otherPath){
	this->_OptionType = otherPath._OptionType;
	this->_SpotPrice = otherPath._SpotPrice;
	this->_RiskFreeRate = otherPath._RiskFreeRate;
	this->_Volatility = otherPath._Volatility;
	this->_InitialPrice = otherPath._InitialPrice;
	this->_TimeToMaturity = otherPath._TimeToMaturity;
	this->_NumberOfIntervals = otherPath._NumberOfIntervals;
	this->_DeltaTime = otherPath._DeltaTime;
	this->_StrikePrice = otherPath._StrikePrice;
	this->_B = otherPath._B;
	this->_N = otherPath._N;
	this->_K = otherPath._K;
	this->_PerformanceCorridorBarrierCounter = otherPath._PerformanceCorridorBarrierCounter;
	this->_NegativePrice = otherPath._NegativePrice;
}

// Public get methods
__device__ __host__ double Path::GetSpotPrice() const{
	return this->_SpotPrice;
}

__device__ __host__ unsigned int Path::GetPerformanceCorridorBarrierCounter() const{
	return this->_PerformanceCorridorBarrierCounter;
}


// Euler and exact steps implementation
__device__ __host__ void Path::EulerLogNormalStep(double gaussianRandomVariable){
	double SpotPrice_i;		//The price at the next step
	SpotPrice_i = (this->_SpotPrice) *
	(1 + *(this->_RiskFreeRate) * this->_DeltaTime
	+ *(this->_Volatility) * sqrt(this->_DeltaTime) * gaussianRandomVariable);
	
	if(*(_OptionType) == 'e')
		this->CheckPerformanceCorridorCondition(this->_SpotPrice, SpotPrice_i);
		
	if(SpotPrice_i < 0)
		this->_NegativePrice = true;
	
	this->_SpotPrice = SpotPrice_i;
}

__device__ __host__ void Path::ExactLogNormalStep(double gaussianRandomVariable){
	double SpotPrice_i;		//The price at the next step
	SpotPrice_i = (this->_SpotPrice) * exp((*(this->_RiskFreeRate)
	- 0.5 * pow(*(this->_Volatility),2)) * this->_DeltaTime
	+ *(this->_Volatility) * gaussianRandomVariable * sqrt(this->_DeltaTime));
	
	if(*(_OptionType) == 'e')
		this->CheckPerformanceCorridorCondition(this->_SpotPrice, SpotPrice_i);
	
	this->_SpotPrice = SpotPrice_i;
}

// Check performance corridor condition
__device__ __host__ void Path::CheckPerformanceCorridorCondition(double currentSpotPrice, double nextSpotPrice){
	double modulusArgument = 1./(sqrt(this->_DeltaTime)) * log(nextSpotPrice / currentSpotPrice);
	double barrier = *(this->_B) * *(this->_Volatility);

	if(fabs(modulusArgument) < barrier)
		++(this->_PerformanceCorridorBarrierCounter);
}

// Evaluate atualized payoff
__device__ __host__ double Path::GetActualizedPayoff() const{
	double payoff;
	
	switch(*(this->_OptionType)){
		case 'f':
			payoff = this->_SpotPrice;
			break;
		
		case 'c':
			payoff = fmax(this->_SpotPrice - *(this->_StrikePrice), 0.);
			break;
		
		case 'p':
			payoff = fmax(*(this->_StrikePrice) - this->_SpotPrice, 0.);
			break;
		
		case 'e':
			payoff = *(this->_N) * fmax((static_cast<double>(this->_PerformanceCorridorBarrierCounter) / *(this->_NumberOfIntervals)) - *(this->_K), 0.);
			break;
			
		default:
			payoff = -10000.;
			break;
	}	
	
	return (payoff * exp(- *(this->_RiskFreeRate) * *(this->_TimeToMaturity)));
}

__device__ __host__ bool Path::GetNegativePrice() const{
	return this->_NegativePrice;
}
\end{lstlisting}

\subsection{\texttt{Statistics}}
Come si può evincere dal nome, la classe \codeword{Statistics} estrapola dati statistici a partire dai risultati di una sequenza di simulazioni. Il risultato finale è immagazzinato nelle variabili \codeword{_PayoffAverage} e \codeword{_PayoffError}, il cui valore viene aggiornato dal metodo \codeword{EvaluateEstimatedPriceAndError()}. Per il calcolo di media e varianza la classe si serve di dati membri d'appoggio contenenti la somma ordinaria e quadratica dei \textit{pay-off} passati a ogni ciclo, nonché di un contatore che tiene traccia del numero di chiamate alla funzione \codeword{AddPayoff(double)}. È poi inserito un ulteriore contatore per i \codeword{Path} contenenti almeno un rendimento negativo del sottostante, casistica trattata nella Sezione \ref{sec:limits}.

La classe così composta è dotata di tutte le caratteristiche necessarie al primo utilizzo che ne viene fatto all'interno del codice, cioè quello di calcolare la media e la varianza dei risultati del singolo \textit{thread} all'interno della funzione \codeword{OptionPricingEvaluator_HostDev(...)}.

Esiste poi un secondo impiego di \codeword{Statistics}: le medie e varianze finali delle simulazioni di ogni \textit{thread} devono essere manipolate per generare un prodotto finale unico. Per farlo abbiamo definito un \textit{overload} dell'operatore \codeword{+=}, così da poter sommare in un singolo oggetto le istanze della classe di ogni \textit{thread}, restituite dall'algoritmo nella forma di due vettori \codeword{Statistics*} (uno per il processo lognormale esatto, l'altro per l'approssimazione di Eulero). 

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/Statistics/Statistics.cuh}}]
#ifndef __Statistics_h__
#define __Statistics_h__

class Statistics{

	private:

		double _PayoffSum;
		double _SquaredPayoffSum;
		unsigned int _PayoffCounter;
		
		double _PayoffAverage;
		double _PayoffError;
		
		unsigned int _NegativePriceCounter;
		
	public:
	
		// Constructor and destructor
		__device__ __host__ Statistics();
		__device__ __host__ ~Statistics() = default;

		// Add argument and its square to the respective sums
		__device__ __host__ void AddPayoff(double payoff);
		
		// Reset sums and counter
		__device__ __host__ void ResetSums();
				
		// Return value of payoffSum or squaredPayoffSum (and respective counters)
		__device__ __host__ double GetPayoffSum() const;
		__device__ __host__ double GetSquaredPayoffSum() const;
		__device__ __host__ unsigned int GetPayoffCounter() const;
		
		// Evaluate average and error
		__device__ __host__ void EvaluateEstimatedPriceAndError();
		__device__ __host__ double GetPayoffAverage() const;
		__device__ __host__ double GetPayoffError() const;
		
		// Manage negative price counter
		__device__ __host__ unsigned int GetNegativePriceCounter() const;
		__device__ __host__ void IncreaseNegativePriceCounter();
		
		// Overload of += operator
		__host__ Statistics& operator+=(const Statistics&);	// Host-only because of isinf, at least for now

};

#endif
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/Statistics/Statistics.cu}}]
#include <cmath>	// pow, sqrt

#include "Statistics.cuh"

using namespace std;

// Constructor
__device__ __host__ Statistics::Statistics(){
	this->_PayoffSum = 0.;
	this->_SquaredPayoffSum = 0.;
	this->_PayoffCounter = 0;
	this->_NegativePriceCounter = 0;
}

// Public methods for addition
__device__ __host__ void Statistics::AddPayoff(double payoff){
	this->_PayoffSum += payoff;
	this->_SquaredPayoffSum += pow(payoff,2);
	++(this->_PayoffCounter);
}

// Public methods for sum resetting
__device__ __host__ void Statistics::ResetSums(){
	this->_PayoffSum = 0.;
	this->_SquaredPayoffSum = 0.;
	this->_PayoffCounter = 0;
	this->_NegativePriceCounter = 0;
}

// Public get methods
__device__ __host__ double Statistics::GetPayoffSum() const{
	return this->_PayoffSum;
}

__device__ __host__ double Statistics::GetSquaredPayoffSum() const{
	return this->_SquaredPayoffSum;
}

__device__ __host__ unsigned int Statistics::GetPayoffCounter() const{
	return this->_PayoffCounter;
}

// Average and error evaluation and output
__device__ __host__ void Statistics::EvaluateEstimatedPriceAndError(){
	this->_PayoffAverage = this->_PayoffSum / this->_PayoffCounter;
	this->_PayoffError = sqrt((this->_SquaredPayoffSum / this->_PayoffCounter - pow(this->_PayoffAverage,2))/ this->_PayoffCounter);
}

__device__ __host__ double Statistics::GetPayoffAverage() const{
	return this->_PayoffAverage;
}


__device__ __host__ double Statistics::GetPayoffError() const{
	return this->_PayoffError;
}

// Operator+= overload
__host__ Statistics& Statistics::operator+=(const Statistics& otherStatistics){

	if(std::isinf(otherStatistics.GetPayoffSum()) || std::isinf(otherStatistics.GetSquaredPayoffSum()))
		return *this;
	
	this->_PayoffSum += otherStatistics.GetPayoffSum();
	this->_SquaredPayoffSum += otherStatistics.GetSquaredPayoffSum();
	this->_PayoffCounter += otherStatistics.GetPayoffCounter();
	this->_NegativePriceCounter += otherStatistics.GetNegativePriceCounter();
	
	return *this;
}

// Manage negative price counter
__device__ __host__ unsigned int Statistics::GetNegativePriceCounter() const{
	return this->_NegativePriceCounter;
}

__device__ __host__ void Statistics::IncreaseNegativePriceCounter(){
	++(this->_NegativePriceCounter);
}
\end{lstlisting}

\subsection{\texttt{Data\_stream\_manager}}
\label{sec:data_stream_manager}
La classe \codeword{Data_stream_manager} è stata sviluppata per ovviare alla necessità di uno strumento per la gestione dei dati di \textit{input} e la raccolta di quelli di \textit{output}. Il cuore di questa libreria è di conseguenza duplice:
\begin{itemize}
    \item il metodo \codeword{ReadInputData(...)}, previa inizializzazione dell'unico dato membro, legge il file \codeword{_InputFile} dove sono contenuti i dati e li inserisce nella struttura di \textit{input} appropriata, ignorando le righe che cominciano con il simbolo \verb|#| (interpretate come commenti);
    \item il metodo \codeword{StoreOutputData(...)} effettua un'operazione simile, ricevendo in ingresso i risultati delle simulazioni e scrivendoli in un oggetto \codeword{Output_MC_data}.
\end{itemize}

Accanto a questa coppia di funzioni ne sono presenti altre due, \codeword{PrintInputData(..)} e \codeword{PrintOutputData(...)}, che gestiscono la stampa a schermo di dati e risultati delle simulazioni facilitandone la raccolta e l'analisi.

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/DataStreamManager/Data\_stream\_manager.cuh}}]
#ifndef _DATA__STREAM__MANAGER_H_
#define _DATA__STREAM__MANAGER_H_

#include <string>	// string

#include "../../InputStructures/InputGPUData/Input_gpu_data.cuh"
#include "../../InputStructures/InputMarketData/Input_market_data.cuh"
#include "../../InputStructures/InputMCData/Input_MC_data.cuh"
#include "../../InputStructures/InputOptionData/Input_option_data.cuh"
#include "../Statistics/Statistics.cuh"
#include "../../OutputStructures/OutputMCData/Output_MC_data.cuh"

class Data_stream_manager{
	
	private:
	
		std::string _InputFile;
	
	public:
	
		__host__ Data_stream_manager();
		__host__ Data_stream_manager(std::string inputFile);
		__host__ ~Data_stream_manager() = default;
		
		// Set input file
		__host__ void SetInputFile(std::string);
	
		// Input processing
		__host__ void ReadInputData(Input_gpu_data&, Input_option_data&, Input_market_data&, Input_MC_data&) const;
		__host__ void PrintInputData(const Input_gpu_data&, const Input_option_data&, const Input_market_data&, const Input_MC_data&) const;

		// Output processing
		__host__ void StoreOutputData(Output_MC_data&, const Statistics exactResults, const Statistics eulerResults, double elapsedTime, char hostOrDevice) const;
		__host__ void PrintOutputData(const Output_MC_data&) const;		
		
	
};

#endif
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/DataStreamManager/Data\_stream\_manager.cu}}]
#include <iostream>
#include <fstream>	// ifstream
#include <string>	// string, stoul, stod, at
#include <vector>	// vector
#include <iomanip>	// setprecision

#include "Data_stream_manager.cuh"
#include "../../InputStructures/InputGPUData/Input_gpu_data.cuh"
#include "../../InputStructures/InputMarketData/Input_market_data.cuh"
#include "../../InputStructures/InputMCData/Input_MC_data.cuh"
#include "../../InputStructures/InputOptionData/Input_option_data.cuh"
#include "../Statistics/Statistics.cuh"
#include "../../OutputStructures/OutputMCData/Output_MC_data.cuh"

using namespace std;

// Constructors
__host__ Data_stream_manager::Data_stream_manager(){
	_InputFile = "blank";
}
__host__ Data_stream_manager::Data_stream_manager(string inputFile){
	_InputFile = inputFile;
}

// Set input file
__host__ void Data_stream_manager::SetInputFile(string inputFile){
	_InputFile = inputFile;	
}

// Input processing
__host__ void Data_stream_manager::ReadInputData(Input_gpu_data& inputGPU, Input_option_data& inputOption, Input_market_data& inputMarket, Input_MC_data& inputMC) const{
	vector<string> inputDataVector;
	ifstream inputFileStream(_InputFile.c_str());
	string line;
	if(inputFileStream.is_open()){
		while(getline(inputFileStream, line))
			if(line[0] != '#')
				inputDataVector.push_back(line);
	}else
		cout << "ERROR: Unable to open file " << _InputFile << "." << endl;
		
	// Input GPU data
	inputGPU.NumberOfBlocks = stoul(inputDataVector[0]);

	// Input market data
	inputMarket.InitialPrice = stod(inputDataVector[1]);
	inputMarket.Volatility = stod(inputDataVector[2]);
	inputMarket.RiskFreeRate = stod(inputDataVector[3]);

	// Input option data
	inputOption.TimeToMaturity = stod(inputDataVector[4]);
	inputOption.NumberOfIntervals = stoul(inputDataVector[5]);
	inputOption.OptionType = inputDataVector[6].at(0);
	inputOption.StrikePrice = stod(inputDataVector[7]);
	inputOption.B = stod(inputDataVector[8]);
	inputOption.K = stod(inputDataVector[9]);
	inputOption.N = stod(inputDataVector[10]);

	// Input Monte Carlo data
	inputMC.NumberOfMCSimulations = stoul(inputDataVector[11]);
	inputMC.CpuOrGpu = inputDataVector[12].at(0);
	inputMC.GaussianOrBimodal = inputDataVector[13].at(0);
}

__host__ void Data_stream_manager::PrintInputData(const Input_gpu_data& inputGPU, const Input_option_data& inputOption, const Input_market_data& inputMarket, const Input_MC_data& inputMC) const{
	cout << endl << "###### INPUT DATA ######" << endl << endl;
	cout << "## GPU AND MC INPUT DATA ##" << endl;
	cout << "Number of blocks: " << inputGPU.NumberOfBlocks << endl;
	cout << "Number of threads per block: " << inputGPU.GetNumberOfThreadsPerBlock() << endl;
	cout << "Total number of threads: " << inputGPU.GetTotalNumberOfThreads() << endl; 
	cout << "Number of simulations: " << inputMC.NumberOfMCSimulations << endl;
	cout << "Number of simulations per thread (round-up): " << inputMC.GetNumberOfSimulationsPerThread(inputGPU) << endl;
	cout << "CPU v. GPU parameter: " << inputMC.CpuOrGpu << endl;
	cout << "Gaussian or bimodal random variable: " << inputMC.GaussianOrBimodal << endl;
	
	cout << "## MARKET DATA ##" << endl;
	cout << "Initial underlying price [USD]: " << inputMarket.InitialPrice << endl;
	cout << "Market volatility: " << inputMarket.Volatility << endl;
	cout << "Risk free rate: " << inputMarket.RiskFreeRate << endl; 
	
	cout << "## OPTION DATA ##" << endl;
	cout << "Option type: " << inputOption.OptionType << endl; 
	cout << "Time to option maturity [years]: " << inputOption.TimeToMaturity << endl;
	cout << "Number of intervals for Euler/exact step-by-step computation: " << inputOption.NumberOfIntervals << endl;
	cout << "Interval time [years]: " << inputOption.GetDeltaTime() << endl;
	switch(inputOption.OptionType){
		case 'p':
		case 'c':
			cout << "Option strike price [USD]: " << inputOption.StrikePrice << endl;
			break;
		
		case 'e':
			cout << "B: " << inputOption.B << endl;
			cout << "K [percentage]: " << inputOption.K << endl;
			cout << "N [EUR]: " << inputOption.N << endl;
		
		case 'f':
		default:
			break;
	}
	
	cout << endl;	
}

// Output processing
__host__ void Data_stream_manager::StoreOutputData(Output_MC_data& outputMC, const Statistics exactResults, const Statistics eulerResults, double elapsedTime, char hostOrDevice) const{
	outputMC.EstimatedPriceMCExact = exactResults.GetPayoffAverage();
	outputMC.ErrorMCExact = exactResults.GetPayoffError();
	outputMC.EstimatedPriceMCEuler = eulerResults.GetPayoffAverage();
	outputMC.ErrorMCEuler = eulerResults.GetPayoffError();
	outputMC.Tick = elapsedTime;
	outputMC.HostOrDevice = hostOrDevice;
	outputMC.NegativePriceCounter = eulerResults.GetNegativePriceCounter();
}

__host__ void Data_stream_manager::PrintOutputData(const Output_MC_data& outputMC) const{
	cout << endl << "## ";
	if(outputMC.HostOrDevice == 'h')
		cout << "HOST";
	else if(outputMC.HostOrDevice == 'd')
		cout << "DEVICE";
	else
		cout << "MISSINGNO.";
	
	cout << " OUTPUT MONTE CARLO DATA ##" << endl;
	cout << "Monte Carlo estimated price via exact formula [EUR]: " << setprecision(20) << outputMC.EstimatedPriceMCExact << endl;
	cout << "Monte Carlo estimated error via exact formula [EUR]: " << setprecision(20) << outputMC.ErrorMCExact << endl;
	cout << "Monte Carlo relative error via exact formula [EUR]: " << setprecision(20) << outputMC.GetRelativeErrorExact() << endl;
	cout << "Monte Carlo estimated price via Euler formula [EUR]: " << setprecision(20) << outputMC.EstimatedPriceMCEuler << endl;
	cout << "Monte Carlo estimated error via Euler formula [EUR]: " << setprecision(20) << outputMC.ErrorMCEuler << endl;
	cout << "Monte Carlo relative error via Euler formula [EUR]: " << setprecision(20) << outputMC.GetRelativeErrorEuler() << endl;
	cout << "Discrepancy between Euler and exact results [units of sigma]: " << setprecision(20) << outputMC.GetEulerToExactDiscrepancy() << endl;
	cout << "Computation time [ms]: " << setprecision(20) << outputMC.Tick << endl;
	cout << "Negative price counter: " << outputMC.NegativePriceCounter << endl;
	
	cout << endl;	
}
\end{lstlisting}

\begin{lstlisting}[language=bash, caption={\texttt{input.dat}}]
####### INPUT DATA FOR OPTION PRICING #######
### Comments beginning with # are ignored ###
#
#
#
## GPU DATA
# Number of GPU blocks
50
## MARKET DATA
# Initial underlying price at t = 0 [USD]
100
# Market volatility
0.25
# Risk-free interest rate [percentage, i.e. 0.1 = 10%]
0.01
## OPTION DATA
## NOTE: for flexibility, all option data are read even if they will not be used
## (e.g. because forward contract does not have a strike price)
## Please don't leave any line empty, use arbitrary values instead
#
## BASE/FORWARD CONTRACT DATA
# Time to maturity [years]
1
# Number of intervals in which TTM is divided
400
# Option type
# f = forward contract
# c = plain vanilla call option
# p = plain vanilla put option
# e = performance corridor option
c
## PLAIN VANILLA OPTION DATA
# Option strike price [USD]
100
## PERFORMANCE CORRIDOR OPTION DATA
# B
1
# K [percentage, i.e. 0.1 = 10%]
0.3
# N [EUR]
1
## MONTE CARLO DATA
# Number of simulations
100000000
# CPU/GPU comparison
# c = cpu-only
# g = gpu-only
# b = both
g
# Gaussian or bimodal (1/-1) random variable
# g = gaussian
# b = bimodal
g
#
#
#############################################
#############################################
\end{lstlisting}

\subsection{\texttt{Support\_functions}}
\label{sec:support_functions}
Sono definite \codeword{Support_functions} le funzioni base dell'algoritmo per il \textit{pricing} delle opzioni, su cui si innestano i singoli processi di calcolo di cui abbiamo discusso nelle sezioni precedenti.

Nello specifico abbiamo implementato due funzioni \codeword{__host__} \codeword{CPUOptionPricingMonte CarloAlgorithm(...)} e \codeword{GPUOptionPricingMonteCarloAlgorithm(...)} che preparano il terreno per l'esecuzione dell'algoritmo di \textit{pricing} su CPU e su GPU. Entrambi i metodi sono dotati di strumenti di controllo dei tempi di calcolo; il secondo si occupa inoltre dei passi necessari per allocare spazio in memoria sulla scheda grafica e copiare oggetti da memoria standard a globale e viceversa. 

Abbiamo altresì implementato separatamente, secondo il paradigma \textit{host-device}, la funzione per l'esecuzione vera e propria della simulazione Monte Carlo. La versione \codeword{__global__} del metodo, definita come \codeword{OptionPricingEvaluator_Global(...)}, assegna l'indice del \textit{thread} secondo lo schema standard di scorrimento lungo la griglia e invoca poi la versione \codeword{__host__ __device__}, sotto il nome di \codeword{OptionPricingEvaluator_HostDev(...)}, che esegue le simulazioni richieste al singolo \textit{thread} definendo due oggetti \codeword{Path} ripristinati allo stato iniziale ogniqualvolta il processo lognormale si arresta alla data di maturità (il tutto è finalizzato a una più efficiente gestione della memoria). La funzione \codeword{__host__} pura \codeword{OptionPricingEvaluator_Host(...)} svolge lo stesso ruolo della corrispettiva \codeword{__global__}; essendo tuttavia destinata all'esecuzione su CPU, essa simula il calcolo parallelo che avviene su scheda grafica richiamando \codeword{OptionPricingEvaluator_HostDev(...)} all'interno di un ciclo \codeword{for} sul numero totale di \textit{thread} richiesti.

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/SupportFunctions/Support\_functions.cuh}}]
#ifndef _SUPPORT_FUNCTIONS_H_
#define _SUPPORT_FUNCTIONS_H_

#include <vector>	// vector
#include <string>	// string

#include "../../InputStructures/InputGPUData/Input_gpu_data.cuh"
#include "../../InputStructures/InputMarketData/Input_market_data.cuh"
#include "../../InputStructures/InputMCData/Input_MC_data.cuh"
#include "../../InputStructures/InputOptionData/Input_option_data.cuh"
#include "../DataStreamManager/Data_stream_manager.cuh"
#include "../Statistics/Statistics.cuh"

// Main evaluators (host-device paradigm)
__host__ void OptionPricingEvaluator_Host(Input_gpu_data, Input_option_data, Input_market_data, Input_MC_data, Statistics* exactOutputs, Statistics* eulerOutputs, unsigned int seed);
__host__ __device__ void OptionPricingEvaluator_HostDev(Input_gpu_data, Input_option_data, Input_market_data, Input_MC_data, Statistics* exactOutputs, Statistics* eulerOutputs, unsigned int seed, unsigned int threadNumber);
__global__ void OptionPricingEvaluator_Global(Input_gpu_data, Input_option_data, Input_market_data, Input_MC_data, Statistics* exactOutputs, Statistics* eulerOutputs, unsigned int seed);

// CPU and GPU algorithms
__host__ void CPUOptionPricingMonteCarloAlgorithm(Data_stream_manager, Input_gpu_data, Input_option_data, Input_market_data, Input_MC_data, unsigned int seed);
__host__ void GPUOptionPricingMonteCarloAlgorithm(Data_stream_manager, Input_gpu_data, Input_option_data, Input_market_data, Input_MC_data, unsigned int seed);

#endif
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/SupportFunctions/Support\_functions.cu}}]
#include <iostream>

#include "Support_functions.cuh"
#include "../../InputStructures/InputGPUData/Input_gpu_data.cuh"
#include "../../InputStructures/InputMarketData/Input_market_data.cuh"
#include "../../InputStructures/InputMCData/Input_MC_data.cuh"
#include "../../InputStructures/InputOptionData/Input_option_data.cuh"
#include "../DataStreamManager/Data_stream_manager.cuh"
#include "../Path/Path.cuh"
#include "../Statistics/Statistics.cuh"
#include "../RandomGenerator/RNG.cuh"
#include "../../OutputStructures/OutputMCData/Output_MC_data.cuh"

using namespace std;

// Main evaluators
__host__ __device__ void OptionPricingEvaluator_HostDev(Input_gpu_data inputGPU, Input_option_data option, Input_market_data market, Input_MC_data inputMC, Statistics* exactOutputs, Statistics* eulerOutputs, unsigned int seed, unsigned int threadNumber){
	
	unsigned int numberOfPathsPerThread = inputMC.GetNumberOfSimulationsPerThread(inputGPU);
	unsigned int numberOfIntervals = option.NumberOfIntervals;
	unsigned int totalNumberOfSimulations = inputMC.NumberOfMCSimulations;

	RNG *supportGenerator = new RNG_Tausworthe(seed+threadNumber);
	RNG *mainGenerator = new RNG_CombinedGenerator;
	mainGenerator->SetInternalState(supportGenerator);
	
	// Dummy variables to reduce memory accesses
	Path exactPath, eulerPath;

	// Cycling through paths, overwriting the same dummy path with the same template path
	for(unsigned int pathNumber=0; pathNumber<numberOfPathsPerThread; ++pathNumber){
		
		// Check if we're not overflowing. Since we decide a priori the number of simulations, some threads will inevitably work less
		if(numberOfPathsPerThread * threadNumber + pathNumber < totalNumberOfSimulations){
			exactPath.ResetToInitialState(market, option);
			eulerPath.ResetToInitialState(market, option);

			// Cycling through steps in each path
			for(unsigned int stepNumber=0; stepNumber<numberOfIntervals; ++stepNumber){
				if(inputMC.GaussianOrBimodal == 'g'){
					exactPath.ExactLogNormalStep(mainGenerator->GetGauss());
					eulerPath.EulerLogNormalStep(mainGenerator->GetGauss());
				}else if(inputMC.GaussianOrBimodal == 'b'){
					exactPath.ExactLogNormalStep(mainGenerator->GetBimodal());
					eulerPath.EulerLogNormalStep(mainGenerator->GetBimodal());
				}
			}

			exactOutputs[threadNumber].AddPayoff(exactPath.GetActualizedPayoff());
			eulerOutputs[threadNumber].AddPayoff(eulerPath.GetActualizedPayoff());
			
			if(eulerPath.GetNegativePrice())
				eulerOutputs[threadNumber].IncreaseNegativePriceCounter();
		}
	}
}

__host__ void OptionPricingEvaluator_Host(Input_gpu_data inputGPU, Input_option_data option, Input_market_data market, Input_MC_data inputMC, Statistics* exactOutputs, Statistics* eulerOutputs, unsigned int seed){
	unsigned int totalNumberOfThreads = inputGPU.GetTotalNumberOfThreads();
	
	for(unsigned int threadNumber=0; threadNumber<totalNumberOfThreads; ++threadNumber)
		OptionPricingEvaluator_HostDev(inputGPU, option, market, inputMC, exactOutputs, eulerOutputs, seed, threadNumber);
}

__global__ void OptionPricingEvaluator_Global(Input_gpu_data inputGPU, Input_option_data option, Input_market_data market, Input_MC_data inputMC, Statistics* exactOutputs, Statistics* eulerOutputs, unsigned int seed){
	unsigned int threadNumber = threadIdx.x + blockDim.x * blockIdx.x;
	OptionPricingEvaluator_HostDev(inputGPU, option, market, inputMC, exactOutputs, eulerOutputs, seed, threadNumber);
}

// CPU and GPU algorithms
__host__ void CPUOptionPricingMonteCarloAlgorithm(Data_stream_manager streamManager, Input_gpu_data inputGPU, Input_option_data inputOption, Input_market_data inputMarket, Input_MC_data inputMC, unsigned int seed){
	unsigned int numberOfThreadsPerBlock = inputGPU.GetNumberOfThreadsPerBlock();
	unsigned int totalNumberOfThreads = inputGPU.GetTotalNumberOfThreads();
	unsigned int numberOfSimulationsPerThread = inputMC.GetNumberOfSimulationsPerThread(inputGPU);

	// Time events creation
	cudaEvent_t cpuEventStart, cpuEventStop;
	float cpuElapsedTime;
	cudaEventCreate(&cpuEventStart);
	cudaEventCreate(&cpuEventStop);
	
	// Output arrays
	Statistics *cpu_exactOutputs = new Statistics[totalNumberOfThreads];
	Statistics *cpu_eulerOutputs = new Statistics[totalNumberOfThreads];
	
	cudaEventRecord(cpuEventStart,0);
	
	// Simulation of device path generation
	cout << endl << "Beginning device simulation through CPU..." << endl;
	OptionPricingEvaluator_Host(inputGPU, inputOption, inputMarket, inputMC, cpu_exactOutputs, cpu_eulerOutputs, seed);
	
	cudaEventRecord(cpuEventStop,0);
	cudaEventSynchronize(cpuEventStop);
	cudaEventElapsedTime(&cpuElapsedTime, cpuEventStart, cpuEventStop);
	
	// Output computation
	Statistics cpu_exactResults;
	Statistics cpu_eulerResults;

	for(unsigned int threadNumber=0; threadNumber<totalNumberOfThreads; ++threadNumber){
		cpu_exactResults += cpu_exactOutputs[threadNumber];
		cpu_eulerResults += cpu_eulerOutputs[threadNumber];
	}

	cpu_exactResults.EvaluateEstimatedPriceAndError();
	cpu_eulerResults.EvaluateEstimatedPriceAndError();

	// Global output MC
	Output_MC_data cpu_outputMC;
	streamManager.StoreOutputData(cpu_outputMC, cpu_exactResults, cpu_eulerResults, cpuElapsedTime, 'h');
	streamManager.PrintOutputData(cpu_outputMC);
	
	// Trash bin section, where segfaults come to die
	delete[] cpu_exactOutputs;
	delete[] cpu_eulerOutputs;
	cudaEventDestroy(cpuEventStart);
	cudaEventDestroy(cpuEventStop);	
}

__host__ void GPUOptionPricingMonteCarloAlgorithm(Data_stream_manager streamManager, Input_gpu_data inputGPU, Input_option_data inputOption, Input_market_data inputMarket, Input_MC_data inputMC, unsigned int seed){
	unsigned int numberOfThreadsPerBlock = inputGPU.GetNumberOfThreadsPerBlock();
	unsigned int totalNumberOfThreads = inputGPU.GetTotalNumberOfThreads();
	unsigned int numberOfSimulationsPerThread = inputMC.GetNumberOfSimulationsPerThread(inputGPU);

	// Time events creation
	cudaEvent_t gpuEventStart, gpuEventStop;
	float gpuElapsedTime;
	cudaEventCreate(&gpuEventStart);
	cudaEventCreate(&gpuEventStop);

	// Output arrays
	Statistics *gpu_exactOutputs = new Statistics[totalNumberOfThreads];
	Statistics *gpu_eulerOutputs = new Statistics[totalNumberOfThreads];
	
	cudaEventRecord(gpuEventStart,0);

	// Memory allocation on GPU
	Statistics *device_gpu_exactOutputs;
	Statistics *device_gpu_eulerOutputs;
	
	cudaMalloc((void **)&device_gpu_exactOutputs, totalNumberOfThreads*sizeof(Statistics));
	cudaMalloc((void **)&device_gpu_eulerOutputs, totalNumberOfThreads*sizeof(Statistics));
	
	cudaMemcpy(device_gpu_exactOutputs, gpu_exactOutputs, totalNumberOfThreads*sizeof(Statistics), cudaMemcpyHostToDevice);
	cudaMemcpy(device_gpu_eulerOutputs, gpu_eulerOutputs, totalNumberOfThreads*sizeof(Statistics), cudaMemcpyHostToDevice);
	
	// Generation of paths
	cout << endl << "Beginning GPU computation..." << endl;
	OptionPricingEvaluator_Global<<<inputGPU.NumberOfBlocks,numberOfThreadsPerBlock>>>(inputGPU, inputOption, inputMarket, inputMC, device_gpu_exactOutputs, device_gpu_eulerOutputs, seed);
	
	// The memories are coming back
	cudaMemcpy(gpu_exactOutputs, device_gpu_exactOutputs, totalNumberOfThreads*sizeof(Statistics), cudaMemcpyDeviceToHost);
	cudaMemcpy(gpu_eulerOutputs, device_gpu_eulerOutputs, totalNumberOfThreads*sizeof(Statistics), cudaMemcpyDeviceToHost);

	cudaFree(device_gpu_exactOutputs);
	cudaFree(device_gpu_eulerOutputs);
	
	cudaEventRecord(gpuEventStop,0);
	cudaEventSynchronize(gpuEventStop);
	cudaEventElapsedTime(&gpuElapsedTime, gpuEventStart, gpuEventStop);
	
	// Output computation
	Statistics gpu_exactResults;
	Statistics gpu_eulerResults;

	for(unsigned int threadNumber=0; threadNumber<totalNumberOfThreads; ++threadNumber){
		gpu_exactResults += gpu_exactOutputs[threadNumber];
		gpu_eulerResults += gpu_eulerOutputs[threadNumber];
	}

	gpu_exactResults.EvaluateEstimatedPriceAndError();
	gpu_eulerResults.EvaluateEstimatedPriceAndError();

	// Global output MC
	Output_MC_data gpu_outputMC;
	streamManager.StoreOutputData(gpu_outputMC, gpu_exactResults, gpu_eulerResults, gpuElapsedTime, 'd');
	streamManager.PrintOutputData(gpu_outputMC);
	
	// Trash bin section, where segfaults come to die
	delete[] gpu_exactOutputs;
	delete[] gpu_eulerOutputs;
	cudaEventDestroy(gpuEventStart);
	cudaEventDestroy(gpuEventStop);
}
\end{lstlisting}

\section{Eseguibili}
Riportiamo in questa sezione una breve descrizione di tutti gli eseguibili che abbiamo implementato.

\subsection{\textit{Unit test}}
Con la dicitura \textit{unit test} indichiamo l'attività di collaudo delle singole unità \textit{software}, ossia dei componenti elementari di un programma; a seconda dello \textit{unit test} in questione questo può corrispondere ai metodi di una struttura, a classi più sofisticate oppure a funzioni singole. Nel nostro caso, gli \textit{unit test} sono costituiti da un eseguibile che lancia dei controlli verificandone il risultato, restituendo $1$ se il controllo è superato e $0$ in caso di fallimento.

Lo scopo generale della procedura di \textit{unit testing} è quello di verificare il corretto funzionamento di parti di programma, permettendo così di individuare precocemente eventuali errori di programmazione. Questo approccio facilita in modo sostanziale la modifica a posteriori della libreria, in quanto gli \textit{unit test} evidenzieranno criticità in potenziali nuovi moduli integrati e nella loro interazione con il codice preesistente.

Durante il nostro progetto abbiamo sviluppato uno \textit{unit test} per ciascuna delle classi e strutture implementate, sfruttandoli proficuamente nella fase di espansione progressiva della libreria; poiché essi sono scarsamente significativi ai fini dell'\textit{option pricing}, non ne riporteremo i codici integrali per brevità.

\subsection{Controlli sui numeri pseudocasuali}
In questa sezione sono presentati due eseguibili relativi a controlli effettuati sui generatori di numeri pseudocasuali.

Il primo è \verb|OutputTest.cu|, utilizzato in Sezione \ref{sec:cpugpu} per verificare la corrispondenza dei risultati ottenuti in CPU e GPU: esso sfrutta il paradigma \textit{host-device} per eseguire nei due casi il medesimo algoritmo di generazione a partire da un \textit{seed} in comune. Il frutto del codice sono tre vettori di numeri casuali per parte (interi generati uniformemente in $[0,\codeword{UINT_MAX}]$, in virgola mobile generati uniformemente in $[0,1]$ e secondo una distribuzione gaussiana di media nulla e varianza unitaria). Questi vettori sono poi confrontati elemento per elemento alla ricerca di discrepanze nei risultati prodotti, attesi esattamente coincidenti.

Nel tentativo di automatizzare questo processo di verifica ci siamo accorti che, verosimilmente a causa di troncamenti operati in maniera differente sui due supporti, i due insiemi di numeri generati non risultavano effettivamente identici nonostante combaciassero a numeri estremamente alti di cifre decimali, rendendo impossibile l'utilizzo dell'operatore \codeword{==}. Per risolvere questo problema abbiamo definito due istanze di una funzione \codeword{AreSame(...)} che verifica la compatibilità di due \codeword{double} o \codeword{unsigned int} entro una precisione dello $0.01\%$. Per quanto questa risoluzione sia molto più grezza rispetto a quella richiesta per ritenere validi gli ordini di grandezza degli errori Monte Carlo, si tenga presente che si tratta di un valore simbolico atto a verificare l'assenza di problematiche strutturali; il paradigma \textit{host-device}, a meno di problemi a livello \textit{hardware} o di spazio in memoria, rende fisiologicamente impossibile che i due insiemi di numeri pseudocasuali generati differiscano al di sotto di tale soglia.

Il secondo eseguibile, \verb|CorrelationTests.cu|, è essenzialmente un'interfaccia che esegue su CPU le funzioni definite nella libreria \codeword{CorrelationToolbox}, restituendo i dati che, opportunamente elaborati, sono stati presentati in Sezione \ref{sec:correlation_check}.

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/RandomGenerator/OutputTest.cu}}]
//
//	OUTPUT & CPU/GPU COMPARISON TEST
//
//	Tests correct generation of pseudorandom numbers and compares CPU to GPU output with same seed.
//

#include <iostream>
#include <ctime>		// time(NULL) for seed
#include <climits>		// UINT_MAX
#include <cmath>		// ceil

#include "RNG.cuh"

using namespace std;

__global__ void RNGen_Global(unsigned int *unsignedNumbers, double *uniformNumbers, double *gaussianNumbers, double *bimodalNumbers, unsigned int totalNumbersToGenerate, unsigned int numbersToGeneratePerThread, unsigned int seed);
__host__ __device__ void RNGen_HostDev(unsigned int *unsignedNumbers, double *uniformNumbers, double *gaussianNumbers, double *bimodalNumbers, unsigned int totalNumbersToGenerate, unsigned int numbersToGeneratePerThread, unsigned int seed, unsigned int threadNumber);
__host__ void RNGen_Host(unsigned int numberOfBlocks, unsigned int numberOfThreadsPerBlock, unsigned int *unsignedNumbers, double *uniformNumbers, double *gaussianNumbers, double *bimodalNumbers, unsigned int totalNumbersToGenerate, unsigned int numbersToGeneratePerThread, unsigned int seed);

bool AreSame(unsigned int, unsigned int);
bool AreSame(double, double);

int main(){

	unsigned int numberOfBlocks = 10;
	unsigned int numberOfThreadsPerBlock = 512;
	unsigned int totalNumberOfThreads = numberOfBlocks * numberOfThreadsPerBlock;
	unsigned int totalNumbersToGenerate = 500000;
	
	unsigned int seed;	
	
	do
		seed = time(NULL);
	while(seed < 129 || seed > UINT_MAX - totalNumberOfThreads);

	unsigned int numbersToGeneratePerThread = ceil(static_cast<double>(totalNumbersToGenerate) / totalNumberOfThreads);
	cout << "Total numbers to generate: " << totalNumbersToGenerate << endl;
	cout << "Total number of threads: " << totalNumberOfThreads << endl;
	cout << "Total numbers to generate per thread: " << numbersToGeneratePerThread << endl;

	// CPU-side results
	unsigned int *cpu_unsignedNumbers = new unsigned int[totalNumbersToGenerate];
	double *cpu_uniformNumbers = new double[totalNumbersToGenerate];
	double *cpu_gaussianNumbers = new double[totalNumbersToGenerate];
	double *cpu_bimodalNumbers = new double[totalNumbersToGenerate];

	// GPU-side results
	unsigned int *gpu_unsignedNumbers = new unsigned int[totalNumbersToGenerate];
	double *gpu_uniformNumbers = new double[totalNumbersToGenerate];
	double *gpu_gaussianNumbers = new double[totalNumbersToGenerate];
	double *gpu_bimodalNumbers = new double[totalNumbersToGenerate];
	
	////////////// HOST-SIDE GENERATOR //////////////
	RNGen_Host(numberOfBlocks, numberOfThreadsPerBlock, cpu_unsignedNumbers, cpu_uniformNumbers, cpu_gaussianNumbers, cpu_bimodalNumbers, totalNumbersToGenerate, numbersToGeneratePerThread, seed);
	/////////////////////////////////////////////////

	////////////// DEVICE-SIDE GENERATOR //////////////
	unsigned int *dev_gpu_unsignedNumbers;
	double *dev_gpu_uniformNumbers, *dev_gpu_gaussianNumbers, *dev_gpu_bimodalNumbers;
	
	cudaMalloc( (void **)&dev_gpu_unsignedNumbers, totalNumbersToGenerate*sizeof(unsigned int) );
	cudaMalloc( (void **)&dev_gpu_uniformNumbers, totalNumbersToGenerate*sizeof(double) );
	cudaMalloc( (void **)&dev_gpu_gaussianNumbers, totalNumbersToGenerate*sizeof(double) );
	cudaMalloc( (void **)&dev_gpu_bimodalNumbers, totalNumbersToGenerate*sizeof(double) );
	
	RNGen_Global<<<numberOfBlocks,numberOfThreadsPerBlock>>>(dev_gpu_unsignedNumbers, dev_gpu_uniformNumbers, dev_gpu_gaussianNumbers, dev_gpu_bimodalNumbers, totalNumbersToGenerate, numbersToGeneratePerThread, seed);

	cudaMemcpy(gpu_unsignedNumbers, dev_gpu_unsignedNumbers, totalNumbersToGenerate*sizeof(unsigned int), cudaMemcpyDeviceToHost);
	cudaMemcpy(gpu_uniformNumbers, dev_gpu_uniformNumbers, totalNumbersToGenerate*sizeof(double), cudaMemcpyDeviceToHost);
	cudaMemcpy(gpu_gaussianNumbers, dev_gpu_gaussianNumbers, totalNumbersToGenerate*sizeof(double), cudaMemcpyDeviceToHost);
	cudaMemcpy(gpu_bimodalNumbers, dev_gpu_bimodalNumbers, totalNumbersToGenerate*sizeof(double), cudaMemcpyDeviceToHost);

	cudaFree(dev_gpu_unsignedNumbers);
	cudaFree(dev_gpu_uniformNumbers);
	cudaFree(dev_gpu_gaussianNumbers);
	cudaFree(dev_gpu_bimodalNumbers);
	///////////////////////////////////////////////////
	
	////////////// TESTS //////////////

	cout << endl << "############### OUTPUT NUMBERS ################" << endl;
	
	cout << endl << "CPU: " << endl;
	cout << "thread\t unsigned\t uniform\t gauss\t bimodal" << endl;
	for(int randomNumber=0; randomNumber<5; ++randomNumber)
		cout << randomNumber << "\t" << cpu_unsignedNumbers[randomNumber] << "\t" << cpu_uniformNumbers[randomNumber] << "\t" << cpu_gaussianNumbers[randomNumber] << "\t" << cpu_bimodalNumbers[randomNumber] << endl;;
	cout << ". . ." << endl;	
	for(int randomNumber=totalNumbersToGenerate-5; randomNumber<totalNumbersToGenerate; ++randomNumber)
		cout << randomNumber << "\t" << cpu_unsignedNumbers[randomNumber] << "\t" << cpu_uniformNumbers[randomNumber] << "\t" << cpu_gaussianNumbers[randomNumber] << "\t" << cpu_bimodalNumbers[randomNumber] << endl;
		
	cout << endl << "GPU: " << endl;
	cout << "thread\t unsigned\t uniform\t gauss" << endl;
	for(int randomNumber=0; randomNumber<5; ++randomNumber)
		cout << randomNumber << "\t" << gpu_unsignedNumbers[randomNumber] << "\t" << gpu_uniformNumbers[randomNumber] << "\t" << gpu_gaussianNumbers[randomNumber] << "\t" << gpu_bimodalNumbers[randomNumber] << endl;
	cout << ". . ." << endl;	
	for(int randomNumber=totalNumbersToGenerate-5; randomNumber<totalNumbersToGenerate; ++randomNumber)
		cout << randomNumber << "\t" << gpu_unsignedNumbers[randomNumber] << "\t" << gpu_uniformNumbers[randomNumber] << "\t" << gpu_gaussianNumbers[randomNumber] << "\t" << gpu_bimodalNumbers[randomNumber] << endl;

	cout << endl << "############### GPU-CPU COMPARISON ################" << endl << endl;
	
	bool gpuCpuComparison = true;
	for(int randomNumber=0; randomNumber<totalNumbersToGenerate; ++randomNumber){
		if(!AreSame(gpu_unsignedNumbers[randomNumber], cpu_unsignedNumbers[randomNumber])){
			gpuCpuComparison = false;
			cout << "FAILED@step " << randomNumber << ":\t" << gpu_unsignedNumbers[randomNumber] << "\t" << cpu_unsignedNumbers[randomNumber] << endl;
		}
		
		if(!AreSame(gpu_uniformNumbers[randomNumber], cpu_uniformNumbers[randomNumber])){
			gpuCpuComparison = false;
			cout << "FAILED@step " << randomNumber << ":\t" << gpu_uniformNumbers[randomNumber] << "\t" << cpu_uniformNumbers[randomNumber] << endl;
		}
		
		if(!AreSame(gpu_gaussianNumbers[randomNumber], cpu_gaussianNumbers[randomNumber])){
			gpuCpuComparison = false;
			cout << "FAILED@step " << randomNumber << ":\t" << gpu_gaussianNumbers[randomNumber] << "\t" << cpu_gaussianNumbers[randomNumber] << endl;
		}
		
		if(!AreSame(gpu_bimodalNumbers[randomNumber], cpu_bimodalNumbers[randomNumber])){
			gpuCpuComparison = false;
			cout << "FAILED@step " << randomNumber << ":\t" << gpu_bimodalNumbers[randomNumber] << "\t" << cpu_bimodalNumbers[randomNumber] << endl;
		}
	}
	
	if(gpuCpuComparison)
		cout << "Test PASSED!" << endl;
	else
		cout << "Test failed..." << endl;

	delete[] cpu_unsignedNumbers;
	delete[] cpu_uniformNumbers;
	delete[] cpu_gaussianNumbers;
	delete[] cpu_bimodalNumbers;
	
	delete[] gpu_unsignedNumbers;
	delete[] gpu_uniformNumbers;
	delete[] gpu_gaussianNumbers;
	delete[] gpu_bimodalNumbers;

	return 0;

}

/////////////////////////////////////////////
///////////////// FUNCTIONS /////////////////
/////////////////////////////////////////////

__global__ void RNGen_Global(unsigned int *unsignedNumbers, double *uniformNumbers, double *gaussianNumbers, double *bimodalNumbers, unsigned int totalNumbersToGenerate, unsigned int numbersToGeneratePerThread, unsigned int seed){
	unsigned int threadNumber = threadIdx.x + blockDim.x * blockIdx.x;
	RNGen_HostDev(unsignedNumbers, uniformNumbers, gaussianNumbers, bimodalNumbers, totalNumbersToGenerate, numbersToGeneratePerThread, seed, threadNumber);
}

__host__ __device__ void RNGen_HostDev(unsigned int *unsignedNumbers, double *uniformNumbers, double *gaussianNumbers, double *bimodalNumbers, unsigned int totalNumbersToGenerate, unsigned int numbersToGeneratePerThread, unsigned int seed, unsigned int threadNumber){
	
	RNG *supportGenerator = new RNG_Tausworthe(seed+threadNumber);
	
	RNG *generator = new RNG_CombinedGenerator;
	generator->SetInternalState(supportGenerator);
	
	unsigned int unsignedNumber;
	double gaussian, uniform, bimodal;

	for(unsigned int RNGNumber=0; RNGNumber<numbersToGeneratePerThread; ++RNGNumber){		
		if(numbersToGeneratePerThread*threadNumber+RNGNumber < totalNumbersToGenerate){
			unsignedNumber = generator->GetUnsignedInt();
			unsignedNumbers[numbersToGeneratePerThread*threadNumber+RNGNumber] = unsignedNumber;

			uniform = generator->GetUniform();
			uniformNumbers[numbersToGeneratePerThread*threadNumber+RNGNumber] = uniform;
		
			gaussian = generator->GetGauss();
			gaussianNumbers[numbersToGeneratePerThread*threadNumber+RNGNumber] = gaussian;
			
			bimodal = generator->GetBimodal();
			bimodalNumbers[numbersToGeneratePerThread*threadNumber+RNGNumber] = bimodal;
		}
	}
}

__host__ void RNGen_Host(unsigned int numberOfBlocks, unsigned int numberOfThreadsPerBlock, unsigned int *unsignedNumbers, double *uniformNumbers, double *gaussianNumbers, double *bimodalNumbers, unsigned int totalNumbersToGenerate, unsigned int numbersToGeneratePerThread, unsigned int seed){
	
	for(unsigned int threadNumber=0; threadNumber<numberOfBlocks*numberOfThreadsPerBlock; ++threadNumber)
			RNGen_HostDev(unsignedNumbers, uniformNumbers, gaussianNumbers, bimodalNumbers, totalNumbersToGenerate, numbersToGeneratePerThread, seed, threadNumber);
}

bool AreSame(unsigned int a, unsigned int b){
	unsigned int diff = a - b;
	double epsilon = 0.0001;	// 0.01% difference
	return (fabs(static_cast<double>(diff) / a) < epsilon);
}
bool AreSame(double a, double b){
	double diff = a - b;
	double epsilon = 0.0001;	// 0.01% difference
	return (fabs(diff / a) < epsilon);	
}
\end{lstlisting}

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/RandomGenerator/CorrelationTest.cu}}]
//
//	INTER- AND INTRA-STREAM CORRELATION TEST
//
//	Tests correlation of random generated numbers within single streams
//	as well as across all streams.
//

#include <iostream>
#include <ctime>		// time(NULL) for seed
#include <climits>		// UINT_MAX

#include "RNG.cuh"
#include "CorrelationToolbox.cuh"

using namespace std;

int main(){
	
	// Verbosities
	bool intraStreamAverageVerbosity = true;
	bool intraStreamVarianceVerbosity = true;
	bool intraStreamKurtosisVerbosity = true;
	bool intraStreamAutocorrelationVerbosity = true;
	
	bool interStreamAverageVerbosity = true;
	bool interStreamVarianceVerbosity = true;
	bool interStreamKurtosisVerbosity = true;
	bool interStreamAutocorrelationVerbosity = true;
	
	
	unsigned int numberOfBlocks = 1;
	unsigned int numberOfThreadsPerBlock = 512;
	unsigned int totalNumberOfThreads = numberOfBlocks * numberOfThreadsPerBlock;
	unsigned int numbersToGeneratePerThread = 1000;
	unsigned int totalNumbersToGenerate = totalNumberOfThreads * numbersToGeneratePerThread;

	cout << "Total numbers to generate: " << totalNumbersToGenerate << endl;
	cout << "Total number of threads: " << totalNumberOfThreads << endl;
	cout << "Total numbers to generate per thread: " << numbersToGeneratePerThread << endl;
	
	double **uniformNumbers = new double*[totalNumberOfThreads];
	double **gaussianNumbers = new double*[totalNumberOfThreads];
	
	for(unsigned int threadIndex=0; threadIndex<totalNumberOfThreads; ++threadIndex){
		uniformNumbers[threadIndex] = new double[numbersToGeneratePerThread];
		gaussianNumbers[threadIndex] = new double[numbersToGeneratePerThread];
	}

	// Seed for Tausworthe support generator
	unsigned int seed;	
	do
		seed = time(NULL);
	while(seed < 129 || seed > UINT_MAX - totalNumberOfThreads);
	

	RandomNumberGeneration(numberOfBlocks, numberOfThreadsPerBlock, uniformNumbers, gaussianNumbers, totalNumbersToGenerate, numbersToGeneratePerThread, seed);
	
	cout << endl <<  "############### INTRA-STREAM TEST ###############" << endl;
	
	// Average, exp. 0.5 for uniform numbers, 0 for gaussian numbers
	double *uniformAverages = new double[totalNumberOfThreads];
	double *gaussAverages = new double[totalNumberOfThreads];
	
	if(intraStreamAverageVerbosity)
		cout << endl << "Uniform averages (exp. 0.5):" << endl;
	EvaluateAverage_MultipleStreams(uniformNumbers, uniformAverages, totalNumberOfThreads, numbersToGeneratePerThread, intraStreamAverageVerbosity);
	
	if(intraStreamAverageVerbosity)
		cout << endl << "Gaussian averages (exp. 0):" << endl;
	EvaluateAverage_MultipleStreams(gaussianNumbers, gaussAverages, totalNumberOfThreads, numbersToGeneratePerThread, intraStreamAverageVerbosity);

	// Gaussian variance, exp. 1
	double *gaussVariances = new double[totalNumberOfThreads];
	if(intraStreamVarianceVerbosity)
		cout << endl << "Gaussian variances (exp. 1):" << endl;
	EvaluateVariance_MultipleStreams(gaussianNumbers, gaussAverages, gaussVariances, totalNumberOfThreads, numbersToGeneratePerThread, intraStreamVarianceVerbosity);
	
	// Gaussian kurtosis, exp. 3
	double *gaussKurtosises = new double[totalNumberOfThreads];
	if(intraStreamKurtosisVerbosity)
		cout << endl << "Gaussian kurtosises (exp. 3):" << endl;
	EvaluateKurtosis_MultipleStreams(gaussianNumbers, gaussAverages, gaussVariances, gaussKurtosises, totalNumberOfThreads, numbersToGeneratePerThread, intraStreamKurtosisVerbosity);

	// Autocorrelation i/i+k, exp. 0.25 for uniform numbers, 0 for gaussian numbers
	double **uniformCorrelations = new double*[totalNumberOfThreads];
	double **gaussCorrelations = new double*[totalNumberOfThreads];
	
	for(unsigned int threadIndex=0; threadIndex<totalNumberOfThreads; ++threadIndex){
		// One component for each autocorrelation offset k (as in xi*xi+k)
		// which runs from 1 to numbersToGeneratePerThread-1
		uniformCorrelations[threadIndex] = new double[numbersToGeneratePerThread-2];	
		gaussCorrelations[threadIndex] = new double[numbersToGeneratePerThread-2];
	}

	if(intraStreamAutocorrelationVerbosity)
		cout << endl << "Uniform autocorrelations i/i+k (exp. 0.25):" << endl;
	EvaluateCompleteAutocorrelation_MultipleStreams(uniformNumbers, uniformCorrelations, totalNumberOfThreads, numbersToGeneratePerThread, intraStreamAutocorrelationVerbosity);
	
	if(intraStreamAutocorrelationVerbosity)
		cout << endl << "Gaussian autocorrelations i/i+k (exp. 0):" << endl;
	EvaluateCompleteAutocorrelation_MultipleStreams(gaussianNumbers, gaussCorrelations, totalNumberOfThreads, numbersToGeneratePerThread, intraStreamAutocorrelationVerbosity);

/////////////////////////////////////

	cout << endl <<  "############### INTER-STREAM TEST ###############" << endl;
	// Build the Super Stream, i.e. the combination of all streams of RNGs
	double *superStreamOfUniformNumbers = new double[totalNumbersToGenerate];
	double *superStreamOfGaussianNumbers = new double[totalNumbersToGenerate];
	
	for(unsigned int RNGIndex=0; RNGIndex<numbersToGeneratePerThread; ++RNGIndex){
		for(unsigned int threadIndex=0; threadIndex<totalNumberOfThreads; ++threadIndex){
			superStreamOfUniformNumbers[RNGIndex*totalNumberOfThreads+threadIndex] = uniformNumbers[threadIndex][RNGIndex];
			superStreamOfGaussianNumbers[RNGIndex*totalNumberOfThreads+threadIndex] = gaussianNumbers[threadIndex][RNGIndex];
		}
	}
	
	// Average, exp. 0.5 for uniform numbers, 0 for gaussian numbers
	double superStreamUniformAverage = GetAverage_SingleStream(superStreamOfUniformNumbers, totalNumbersToGenerate);
	double superStreamGaussAverage = GetAverage_SingleStream(superStreamOfGaussianNumbers, totalNumbersToGenerate);
	if(interStreamAverageVerbosity){
		cout << "Uniform super stream avg (exp. 0.5):\t" << superStreamUniformAverage << endl;
		cout << "Gaussian super stream avg (exp. 0):\t" << superStreamGaussAverage << endl;
	}
	
	// Gaussian variance, exp. 1
	double superStreamGaussianVariance = GetVariance_SingleStream(superStreamOfGaussianNumbers, superStreamGaussAverage, totalNumbersToGenerate);
	if(interStreamVarianceVerbosity){
		cout << "Gaussian super stream variance (exp. 1):\t" << superStreamGaussianVariance << endl;
	}
	
	// Gaussian kurtosis, exp. 3
	double superStreamGaussianKurtosis = GetKurtosis_SingleStream(superStreamOfGaussianNumbers, superStreamGaussAverage, superStreamGaussianVariance, totalNumbersToGenerate);
	if(interStreamKurtosisVerbosity){
		cout << "Gaussian super stream kurtosis (exp. 3):\t" << superStreamGaussianKurtosis << endl;
	}
	
	// Autocorrelation i/i+k, exp. 0.25 for uniform numbers, 0 for gaussian numbers
	double *superStreamUniformCorrelations = new double[totalNumbersToGenerate-2];
	double *superStreamGaussianCorrelations = new double[totalNumbersToGenerate-2];
	if(interStreamAutocorrelationVerbosity)
		cout << "Uniform super stream autocorrelation (exp. 0.25):" << endl;
	EvaluateCompleteAutocorrelation_SingleStream(superStreamOfUniformNumbers, superStreamUniformCorrelations, totalNumbersToGenerate, interStreamAutocorrelationVerbosity);
	if(interStreamAutocorrelationVerbosity)
		cout << "Gaussian super stream autocorrelation (exp. 0):" << endl;
	EvaluateCompleteAutocorrelation_SingleStream(superStreamOfGaussianNumbers, superStreamGaussianCorrelations, totalNumbersToGenerate, interStreamAutocorrelationVerbosity);

/////////////////////////////////////////

	// Quite a lot of space to free up
	delete[] uniformAverages;
	delete[] gaussAverages;
	delete[] gaussVariances;
	delete[] gaussKurtosises;

	for(unsigned int threadIndex=0; threadIndex<totalNumberOfThreads; ++threadIndex){
		delete[] uniformCorrelations[threadIndex];
		delete[] gaussCorrelations[threadIndex];
		delete[] uniformNumbers[threadIndex];
		delete[] gaussianNumbers[threadIndex];
	}
	
	delete[] uniformCorrelations;
	delete[] gaussCorrelations;
	delete[] superStreamUniformCorrelations;
	delete[] superStreamGaussianCorrelations;

	delete[] superStreamOfUniformNumbers;
	delete[] superStreamOfGaussianNumbers;
	delete[] uniformNumbers;
	delete[] gaussianNumbers;
	
	return 0;

}
\end{lstlisting}

\subsection{Confronto con i risultati analitici}
Il test che riportiamo di seguito è stato utilizzato nella Sezione \ref{sec:MC-BS} per verificare la compatibilità dei risultati ottenuti attraverso le simulazioni e i valori analitici esatti. 

Nel codice sono state implementate due funzioni \codeword{ GetBlackAndScholesCallPrice(...)} e \codeword{ GetBlackAndScholesPutPrice(...)} per il calcolo del prezzo attraverso la formula analitica di Black e Scholes rispettivamente per una opzione \textit{plain vanilla call} \eqref{eq:BS_call} e una \textit{plain vanilla put} \eqref{eq:BS_put}. La gestione dei dati relativi al mercato e alle opzioni è affidata a un oggetto \codeword{Data_stream_manager} come spiegato nel dettaglio in Sezione \ref{sec:data_stream_manager}.

\begin{lstlisting}[language=C++, caption={\texttt{libraries/CoreLibraries/Path/BlackScholesUnitTest.cu}}]
#include <iostream>
#include <iomanip>

#include "../../InputStructures/InputMarketData/Input_market_data.cuh"
#include "../../InputStructures/InputOptionData/Input_option_data.cuh"
#include "../../InputStructures/InputGPUData/Input_gpu_data.cuh"
#include "../../InputStructures/InputMCData/Input_MC_data.cuh"
#include "../../CoreLibraries/DataStreamManager/Data_stream_manager.cuh"
#include "../../CoreLibraries/SupportFunctions/Support_functions.cuh"
#include "Path.cuh"

using namespace std;

// Black & Scholes formula
__host__ double GetBlackAndScholesCallPrice(const Input_market_data& inputMarket, const Input_option_data& inputOption){
	double d1 = 1./(inputMarket.Volatility * sqrt(inputOption.TimeToMaturity)) 
	* (log(inputMarket.InitialPrice / inputOption.StrikePrice)
	+ (inputMarket.RiskFreeRate + pow(inputMarket.Volatility,2)/2) * inputOption.TimeToMaturity);

	double d2 = d1 -  inputMarket.Volatility * sqrt(inputOption.TimeToMaturity);

	double callPrice = inputMarket.InitialPrice * (0.5 * (1. + erf(d1/sqrt(2.)))) - inputOption.StrikePrice 
	* exp(- inputMarket.RiskFreeRate * inputOption.TimeToMaturity)
	* (0.5 * (1. + erf(d2/sqrt(2.))));

	return callPrice;	 
}

__host__ double GetBlackAndScholesPutPrice(const Input_market_data& inputMarket, const Input_option_data& inputOption){
	double d1 = 1./(inputMarket.Volatility * sqrt(inputOption.TimeToMaturity)) 
	* (log(inputMarket.InitialPrice / inputOption.StrikePrice)
	+ (inputMarket.RiskFreeRate + pow(inputMarket.Volatility,2)/2) * inputOption.TimeToMaturity);

	double d2 = d1 -  inputMarket.Volatility * sqrt(inputOption.TimeToMaturity);

	double putPrice = inputMarket.InitialPrice * ((0.5 * (1. + erf(d1/sqrt(2.)))) - 1) - inputOption.StrikePrice
	* exp(- inputMarket.RiskFreeRate * inputOption.TimeToMaturity)
	* ((0.5 * (1. + erf(d2/sqrt(2.)))) - 1);

	return putPrice;

}

int main(){
    
    cout << "\n-------------Black and Scholes test-------------\n";

	// Read & print input data from file
	Data_stream_manager streamManager("input.dat");
	
	Input_gpu_data inputGPU;
	Input_option_data inputOption;
	Input_market_data inputMarket;
	Input_MC_data inputMC;
	streamManager.ReadInputData(inputGPU, inputOption, inputMarket, inputMC);
	streamManager.PrintInputData(inputGPU, inputOption, inputMarket, inputMC);

	if(inputOption.OptionType == char('c')) cout << "Black and Scholes Call price: " << setprecision(20) << GetBlackAndScholesCallPrice(inputMarket, inputOption) << endl << endl;
	if(inputOption.OptionType == char('p')) cout << "Black and Scholes Put price: " << setprecision(20) << GetBlackAndScholesPutPrice(inputMarket, inputOption) << endl << endl;
	
    return 0;
}
\end{lstlisting}

\subsection{\texttt{main.cu}}
Viene qui riportato il file contenente la funzione \codeword{main()} del programma, che si occupa di estrarre il \textit{seed} dal generatore di supporto \codeword{RNG_Tausworthe}, leggere i dati di input dal file \verb|input.dat| (si veda la Sezione \ref{sec:data_stream_manager}) ed effettuare le simulazioni su GPU e/o CPU a seconda delle necessità. Per i dettagli dell'algoritmo si veda la Sezione \ref{sec:support_functions}.

\begin{lstlisting}[language=C++, caption={\texttt{main.cu}}]
#include <iostream>
#include <ctime>		// time(NULL)
#include <climits>		// UINT_MAX

#include "libraries/InputStructures/InputGPUData/Input_gpu_data.cuh"
#include "libraries/InputStructures/InputMarketData/Input_market_data.cuh"
#include "libraries/InputStructures/InputMCData/Input_MC_data.cuh"
#include "libraries/InputStructures/InputOptionData/Input_option_data.cuh"
#include "libraries/CoreLibraries/DataStreamManager/Data_stream_manager.cuh"
#include "libraries/CoreLibraries/SupportFunctions/Support_functions.cuh"

using namespace std;

int main(){
	
	// Read & print input data from file
	Data_stream_manager streamManager("input.dat");
	
	Input_gpu_data inputGPU;
	Input_option_data inputOption;
	Input_market_data inputMarket;
	Input_MC_data inputMC;
	streamManager.ReadInputData(inputGPU, inputOption, inputMarket, inputMC);
	streamManager.PrintInputData(inputGPU, inputOption, inputMarket, inputMC);

	// Seed for random number generation
	// Fix it to a value between 129 and UINT_MAX-totalNumberOfThreads or let time(NULL) do its magic
	unsigned int seed;	
	do
		seed = time(NULL);
	while(seed < 129 || seed > UINT_MAX - inputGPU.GetTotalNumberOfThreads());	
	
	////////////// HOST-SIDE ALGORITHM //////////////
	if(inputMC.CpuOrGpu == 'c' || inputMC.CpuOrGpu == 'b')
		CPUOptionPricingMonteCarloAlgorithm(streamManager, inputGPU, inputOption, inputMarket, inputMC, seed);


	////////////// DEVICE-SIDE ALGORITHM //////////////
	if(inputMC.CpuOrGpu == 'g' || inputMC.CpuOrGpu == 'b')
		GPUOptionPricingMonteCarloAlgorithm(streamManager, inputGPU, inputOption, inputMarket, inputMC, seed);

	return 0;
}
\end{lstlisting}