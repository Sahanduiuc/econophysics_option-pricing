\chapter{(F) Programmazione in CUDA di tipo avanzato} \label{cap:cudacpp}

\section{(F-1) Note sull'implementazione della struttura a classi nella libreria}
In ragione dell'elevata complessità dei risultati richiesti e delle tempistiche prolungate di sviluppo, la libreria di \textit{pricing} esposta in questa relazione è stata fin dal principio da noi concepita in un'ottica di massima estensibilità, incapsulando le funzioni chiave per i nostri scopi in classi C++ secondo il paradigma della programmazione orientata agli oggetti. Ciò emerge con estrema chiarezza nella classe \codeword{Data_stream_manager}, progettata per la gestione dei flussi di \textit{input} e \textit{output}: nonostante la libreria sia stata progressivamente ampliata con opzioni accessorie quali il confronto dei tempi di esecuzione in GPU e GPU oppure la scelta di una variabile stocastica gaussiana o binaria, la varietà di strutture dati ha permesso di non modificare mai la segnatura del metodo \codeword{ReadInputData(...)}, atto alla lettura dei dati in ingresso da un file \codeword{input.dat} in continuo mutamento.

Un discorso a parte va fatto per l'introduzione della variabile bimodale oggetto di studio del Capitolo \ref{cap:bimodal}. Non lavorando in un ambiente di programmazione procedurale, la nostra scelta per l'implementazione è stata di definire un nuovo metodo virtuale \codeword{GetBimodal()} all'interno della classe \codeword{RNG}: così facendo non è stata necessaria alcuna modifica della classe \codeword{Path}, in quanto il processo lognormale in schema esatto \eqref{eq:exactprice} si adattava già perfettamente ai nostri scopi. Per applicare questa strada abbiamo però dovuto modificare a cascata tutti i generatori concreti derivati da \codeword{RNG}, operazione che in ambito procedurale non sarebbe necessariamente fattibile.

A riprova dell'efficacia di un'architettura a classi, tuttavia, possiamo citare opzioni più dispendiose dal punto di vista della scrittura del codice ma del tutto applicabili in un paradigma a \textit{subroutine}. Un approccio ideale nelle prime fasi di progettazione del codice sarebbe stato separare la classe per la generazione di numeri pseudocasuali da quella che definisce le distribuzioni di estrazione, su modello dei generatori implementati nella libreria C++11 \codeword{<random>}. Combinando questo accorgimento con la scrittura di un nuovo metodo \codeword{BimodalStep(double)} nella classe \codeword{Path}, ciò avrebbe garantito estensibilità anche nel caso di processi diversi dai due lognormali già presenti senza apportare cambiamenti significativi alla funzione di \textit{pricing} principale.

Concludiamo menzionando un altro vantaggio del paradigma a classi da noi riscontrato, ovvero la possibilità di <<nascondere>> efficacemente i meccanismi interni della libreria all'utente. Un caso esemplare è fornito nuovamente dalla classe \codeword{RNG}: ogni generatore è dotato di un metodo \codeword{SetInternalState(RNG*)} che permette di inizializzarlo senza preoccuparsi del numero di \textit{seed} interni necessari a partire da un puntatore a un generatore qualunque. Nel contesto di programmazione su GPU, ciò ha altresì permesso di risparmiare spazio in memoria evitando di allocare una matrice di $4 N_\text{thread}$ \codeword{unsigned int} necessari per istanziare un generatore combinato indipendente per \textit{thread}.